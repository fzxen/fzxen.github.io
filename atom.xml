<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zxfan</title>
  
  <subtitle>zxfan&#39;s Blog</subtitle>
  <link href="https://zxffan.github.io/atom.xml" rel="self"/>
  
  <link href="https://zxffan.github.io/"/>
  <updated>2023-06-30T11:14:18.598Z</updated>
  <id>https://zxffan.github.io/</id>
  
  <author>
    <name>zxfan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识ProtocolBuffers</title>
    <link href="https://zxffan.github.io/posts/673cef84.html"/>
    <id>https://zxffan.github.io/posts/673cef84.html</id>
    <published>2021-07-15T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Protocol-Buffers"><a href="#什么是Protocol-Buffers" class="headerlink" title="什么是Protocol Buffers"></a>什么是Protocol Buffers</h2><blockquote><p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p><p>——Google</p></blockquote><p>pb是google推出的一个语言无关、平台无关、可扩展的数据序列化机制，它用来序列化类似xml的结构化数据。</p><p>PB有着许多优点：</p><ol><li>强类型约束</li><li>序列化结果是二进制数据</li><li>性能好</li></ol><p>比如JSON数据这种结构化数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zxfan&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="number">123213</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span>: <span class="string">&quot;xxx@xx.com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到JSON的缺点：没有类型约束。我们可以尝试使用PB对这块数据进行定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.proto</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>message</code>用于定义数据结构，Person有三个字段。两个字符串类型（name和email）。一个32位整型（email）。</p><h2 id="PB2的语法"><a href="#PB2的语法" class="headerlink" title="PB2的语法"></a>PB2的语法</h2><p><code>protocol buffers</code>有<code>proto2</code>和<code>proto3</code>两个版本，默认是<code>proto2</code>。</p><h3 id="定义一个message"><a href="#定义一个message" class="headerlink" title="定义一个message"></a>定义一个message</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>message</code>用于定义一个message结构，message里每个字段（field）的由几部分组成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[field rule] [field type] [field name] = [field number]</span><br></pre></td></tr></table></figure><h3 id="Field-Rule"><a href="#Field-Rule" class="headerlink" title="Field Rule"></a>Field Rule</h3><ul><li><code>required</code>：指定字段是必须的</li><li><code>optionsal</code>：指定字段是可选</li><li><code>repeated</code>：指定字段是可重复的，类似数组</li></ul><p>optional的字段是可以添加默认值的，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="Field-Type"><a href="#Field-Type" class="headerlink" title="Field Type"></a>Field Type</h3><p>定义字段类型，字段类型可以是<strong>标量类型</strong>也可以是一个<strong>message</strong></p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>所支持的标量类型，请查阅<a href="https://developers.google.cn/protocol-buffers/docs/proto#scalar">官网文档</a></p><h4 id="Message作为Field类型"><a href="#Message作为Field类型" class="headerlink" title="Message作为Field类型"></a>Message作为Field类型</h4><p>如下例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">  UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">  WEB = <span class="number">1</span>;</span><br><span class="line">  IMAGES = <span class="number">2</span>;</span><br><span class="line">  LOCAL = <span class="number">3</span>;</span><br><span class="line">  NEWS = <span class="number">4</span>;</span><br><span class="line">  PRODUCTS = <span class="number">5</span>;</span><br><span class="line">  VIDEO = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">optional</span> Corpus corpus = <span class="number">4</span> [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Field-Name"><a href="#Field-Name" class="headerlink" title="Field Name"></a>Field Name</h3><p>定义字段名称</p><h3 id="Field-Number"><a href="#Field-Number" class="headerlink" title="Field Number"></a>Field Number</h3><p>定义字段编号。pb被编码成二进制数据，这个编号就是用来标识字段的。</p><ul><li>字段编号必须唯一，不能两个字段使用同一个数字。（只要确保同一个message中不重复就行）</li><li>编号1～15会被编码成1个字节，而16～2047会被编码成2个字节。所以要尽可能多得使用1～15。</li><li>最小编号1，最大编号2^29 - 1。</li></ul><h3 id="Reserved"><a href="#Reserved" class="headerlink" title="Reserved"></a>Reserved</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>; <span class="comment">// 保留 field number</span></span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>; <span class="comment">// 保留 field name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reserved</code>意味着指定的<code>field number</code>或<code>field name</code>不能被使用。</p><p>这在一些场景下十分有用——如果你删除了某个message的field，那么对应的field number就可以被其他field使用了。但是如果其他人使用的是旧版的proto文件，这是就会发生问题，因为PB是通过number来鉴别field的。</p><p>所以，当我们删除某个字段时，考虑一下这个number能否被复用。如果不能，那就使用<code>reserved</code>避免使用到该number。</p><p><code>enum</code>也是支持<code>reserved</code>的</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>, <span class="number">40</span> to max;</span><br><span class="line">  reserved <span class="string">&quot;FOO&quot;</span>, <span class="string">&quot;BAR&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><code>message</code>能够嵌套<code>message</code>和<code>enum</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">EnumLike</span> &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    STARTED = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> EnumLike like = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>注意：这个特性不支持<code>Java</code>语言</p><p>我们通常讲不通的message拆分到不通的<code>.proto</code>文件中。我们可以使用<code>import</code>来复用<code>.proto</code>的内容</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;other_proto.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就可以使用other_proto.proto的内容了</span></span><br></pre></td></tr></table></figure><p>还有一个<code>import public</code>语句。举个例子：有<code>a.protp</code> <code>b.proto</code> <code>c.proto</code> <code>d .proto</code>四个<code>.proto</code>文件，其中<code>b.proto</code>内容如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> public <span class="string">&quot;a.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;d.proto&quot;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>然后<code>c.proto</code>再导入<code>b.proto</code>文件，这样c就可以使用a和b中的定义的内容</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;b.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够使用a.proto和b.proto定义的内容</span></span><br><span class="line"><span class="comment">// 但不包括d.proto，因为b使用的是不加public的import</span></span><br></pre></td></tr></table></figure><p>所以加上<code>public</code>后，就具有传递行了。</p><p>特别注意：我们在使用pb命令行工具时，可用通过添加参数<code>-I/--proto_path</code>，用于指定寻找文件的位置。如果没有指定默认取当前工作路径（就是命令执行的目录）。</p><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>PB提供一套扩展机制，可以对现有message进行扩展（类似类继承）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  extensions <span class="number">100</span> to <span class="number">199</span>; </span><br><span class="line">  <span class="comment">// 100 to max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extensions</code>关键字表明100~199的编号是为扩展保留的。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> bar = <span class="number">126</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extend</code>关节字后加上message name，表示对该message进行扩展。新加字段只能使用100～199作为编号。</p><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h3><p>&#x2F;&#x2F; TODO</p><h2 id="JavaScript如何使用PB"><a href="#JavaScript如何使用PB" class="headerlink" title="JavaScript如何使用PB"></a>JavaScript如何使用PB</h2><p>&#x2F;&#x2F; TODO</p><p>因为是语言无关的，可以在<a href="https://developers.google.cn/protocol-buffers">官网</a>找到相对应的语言指导</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protobuf =  <span class="built_in">require</span>(<span class="string">&#x27;protocol-buffers&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建schema</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="title function_">protobuf</span>(fs.<span class="title function_">redFileSync</span>(__dirname + <span class="string">&#x27;./person.proto&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="keyword">const</span> buf = schema.<span class="property">Column</span>.<span class="title function_">encode</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zxfan&quot;</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&quot;zxfan@xx.com&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">const</span> data = schema.<span class="property">Column</span>.<span class="title function_">decode</span>(buf)</span><br></pre></td></tr></table></figure><p>编码会将原数据编码成二进制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Protocol-Buffers&quot;&gt;&lt;a href=&quot;#什么是Protocol-Buffers&quot; class=&quot;headerlink&quot; title=&quot;什么是Protocol Buffers&quot;&gt;&lt;/a&gt;什么是Protocol Buffers&lt;/h2&gt;&lt;bloc</summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
  </entry>
  
  <entry>
    <title>Crypto</title>
    <link href="https://zxffan.github.io/posts/6f842db3.html"/>
    <id>https://zxffan.github.io/posts/6f842db3.html</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希算法又称为散列算法。将一个任意长度的的数组作为输入，能够获得固定长度的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(crypto.<span class="title function_">getHashes</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MD4&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MD5&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MDC2&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-RIPEMD160&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA1&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA1-2&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA224&#x27;,</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以<code>md5</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5 = crypto.<span class="title function_">createHash</span>(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = md5.<span class="title function_">update</span>(text).<span class="title function_">digest</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><ul><li><code>createHash</code>：创建hash，参数为hash算法，具体见<code>crypto.getHashes()</code></li><li><code>update</code>：对字符串进行hash</li><li><code>digest</code>：获取信息摘要<ul><li>不传参数，返回Buffer</li><li>参数为字符编码，<code>hex</code>返回16进制</li></ul></li></ul><p>md5是不可逆的，破解md5也只能使用暴力的“碰撞破解”。所以一般会对文本进行多次md5哈希：<code>md5.update(text).update(text).update(text)</code></p><blockquote><p>哈希算法通常用作信息摘要算法，比如双发通信时，发送方将资源（数据，用户）的信息摘要进行加密，接收方再去验证比对</p></blockquote><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p><code>Hmac</code>被称为加盐算法，即 <code>Hmac = hash + 密钥</code>。比如<code>sha-1</code>算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = crypto.<span class="title function_">createHmac</span>(<span class="string">&quot;sha1&quot;</span>, <span class="string">&quot;miyao&quot;</span>).<span class="title function_">update</span>(text).<span class="title function_">digest</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 09ef939a42b909a48d8ea3803692ec88eedc4c04</span></span><br></pre></td></tr></table></figure><p><code>createHmac</code>第二个参数密钥</p><blockquote><p>密钥可以通过<code>openssl</code>来创建</p><p><code>openssl genrsa -out rsa_private.key 1024</code></p></blockquote><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密指：利用同一个密钥来加密&#x2F;解密数据。这有两个关键点：</p><ul><li>有加密也有解密，所以加密算法是可逆的</li><li>同一个密钥</li></ul><p>以<code>aes192</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> key = crypto.<span class="title function_">scryptSync</span>(<span class="string">&quot;woshimiyao&quot;</span>, <span class="string">&quot;yanzhi&quot;</span>, <span class="number">24</span>); <span class="comment">// 密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encrypt</span>(<span class="params">data, iv</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&quot;aes192&quot;</span>, key, iv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cipher.<span class="title function_">update</span>(data, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;hex&quot;</span>).<span class="title function_">final</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decrypt</span>(<span class="params">data, iv</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> decipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&quot;aes192&quot;</span>, key, iv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decipher.<span class="title function_">update</span>(data, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;utf-8&quot;</span>).<span class="title function_">final</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iv = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">16</span>, <span class="number">0</span>); <span class="comment">// 初始化向量</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="title function_">encrypt</span>(text, iv);</span><br><span class="line"><span class="keyword">const</span> d = <span class="title function_">decrypt</span>(e, iv);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e, d); <span class="comment">// 3e07418b2c1ed2b128943b005610f166 hello crypto!</span></span><br></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密：利用两个密钥，一个用于加密另一个用于解密。这也有两个关键点：</p><ul><li>有加密也有解密，所以加密算法是可逆的</li><li>两个密钥：<ul><li>公钥：用于加密</li><li>私钥：用于解密</li></ul></li></ul><h2 id="常见加密算法"><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a>常见加密算法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h2&gt;&lt;p&gt;哈希算法又称为散列算法。将一个任意长度的的数组作为输入，能够获得固定长度的输出。&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="Nodejs" scheme="https://zxffan.github.io/tags/Nodejs/"/>
    
    <category term="crypto" scheme="https://zxffan.github.io/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试</title>
    <link href="https://zxffan.github.io/posts/33f3fd9d.html"/>
    <id>https://zxffan.github.io/posts/33f3fd9d.html</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li><p>自我介绍</p></li><li><p>网络模型：osi七层模型，每层干什么的？</p></li><li><p>http协议的理解。想到啥说啥。就是你随便说，面试官会顺着问</p><ol><li>无状态</li><li>应用层协议，基于tcp</li><li>发展历史：从0.9到3.0</li><li>缓存</li><li>http状态吗：从1xx一直说到5xx</li></ol></li><li><p>https？说了一下tls协商</p></li><li><p>es6相关，说一些用过哪些？面试官会顺着问。</p><ol><li>var&#x2F;let&#x2F;const ， 面试官顺着问了它们的区别</li><li>字符串有哪些方法。这个问题应该是问错了，他想问得是数组：map filter reduce sort…</li><li>模块规范 esm cjs 区别</li><li>promise，然后就开始手写。估计他最初是想让我实现数组相关的方法，但是发现自己问错了就跳过了。</li></ol></li><li><p>3道题</p><ol><li>Promise.all</li><li>快排、归并，dfs选一个写</li><li>最小银币找零问题：现有[1,2,5,9,10]几种硬币，当有18面值的硬币时，如何找零使得硬币数量最少；答案是2——18 &#x3D; 9+9</li></ol></li><li><p>感受：一面还是非常基础的。问了挺多的网络相关的内容</p></li></ol><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol><li><p>自我介绍？没让自我介绍直接开始。</p></li><li><p>看简历：</p><ol><li>问你是怎么优化（webpack）构建性能的？<ol><li>缓存：如何根据js代码变化去修改缓存的？</li><li>thread-loader 怎么选取进程数量的？</li><li>如何去做chunk拆分，怎么考量的？</li></ol></li><li>cli脚手架 怎么设计的？</li></ol></li><li><p>vue的computed如何进行依赖收集？说了computed的实现机制。</p></li><li><p>vue3相对于vue2做了哪些改进？讲了响应式和compiler的优化（静态提升、pathFlag、BlockTree）</p></li><li><p>手写题目：类似vue中的渲染函数（render），让你生成dom元素（返回一个dom对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;container&quot;</span> &#125;, [</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;span&quot;</span>, &#123;&#125;, [<span class="string">&quot;hello world&quot;</span>]),</span><br><span class="line">]);</span><br><span class="line">vnode.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure></li><li><p>场景题：</p><p>一个多语言应用，大概14种语言。假如每个语言都放在一个js文件中（中文的一个文件，英文的一个文件）。目前存在两个问题</p><ul><li>应用启动时，会加载这14种语言（js文件），但实际上只需要1种语言，问如何优化？</li><li>随着开发，有一些语言的值不在使用了，但还是加载到内存中去了，如何优化？</li></ul></li><li><p>感受：二面连自我介绍都省了，哈哈！！感觉面试官爱从编译的角度问问题，估计这和他的具体工作相关吧。总体感觉这位面试官还是不错的，问得都是比较实际的问题。</p></li></ol><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>三面聊得特别广，也挺深的。</p><ol><li><p>之前性能优化怎么做的，这个聊了很久</p></li><li><p>cdn为什么会快？</p></li><li><p>从url到页面渲染的过程</p><ol><li>知道http如何判断响应返回的吗？</li><li>script 加载为什么会阻塞dom解析，既然有defer和async，为什么浏览器不默认defer&#x2F;async?</li></ol></li><li><p>js中函数是一等公民。js中函数可以返回一个函数（闭包），知道这个特性实现难点在哪吗？</p></li><li><p>你的项目（自己的开源项目）有做过设计吗？看过设计相关的书吗？</p><ol><li>设计模式</li><li>函数式编程</li></ol></li><li><p>你项目写了虚拟列表优化，怎么做的</p><ol><li>滚动得快的话，出现白屏怎么优化？</li><li>如果高度不固定，怎么实现？</li></ol></li><li><p>为什么会学习electron？</p><ol><li>electron的进程模型</li><li>浏览器的进程模型</li></ol></li><li><p>手写题：</p><p>场景：根据ip判断ip所在范围，要求：尽可能高效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如在这两个范围内的 是中国的ip</span></span><br><span class="line"><span class="keyword">const</span> db = [</span><br><span class="line">  [<span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;10.0.0.0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;11.0.0.0&quot;</span>, <span class="string">&quot;200.0.0.0&quot;</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip: string，判断ip是否是中国ip</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInChain</span>(<span class="params">ip</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>感觉三面的面试官的职责可能不仅仅是前端，喜欢问一些特别底层的问题。</p><blockquote><p>三轮技术面试都没有怎么考算法，就一面考了一道动态规划。飞书的面试官还是比较注重实际的开发能力的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络模型：osi七层模型，每层干什么的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;h</summary>
      
    
    
    
    <category term="self" scheme="https://zxffan.github.io/categories/self/"/>
    
    
    <category term="前端" scheme="https://zxffan.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="interview" scheme="https://zxffan.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>clear 清除浮动</title>
    <link href="https://zxffan.github.io/posts/d8bddba6.html"/>
    <id>https://zxffan.github.io/posts/d8bddba6.html</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>clear用于解决，由于float造成的浮动塌陷问题。</p><h2 id="只能清除前面的浮动"><a href="#只能清除前面的浮动" class="headerlink" title="只能清除前面的浮动"></a>只能清除前面的浮动</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.a</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.b</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.c</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.b</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: left</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论对<code>b</code>设置<code>clear: left/right/both</code>。都只能清除<code>a</code>的浮动（a将独占一行），然而无法清除b的浮动。这是因为浏览器的解析顺序的缘故。</p><p>那么<code>clear: right</code>有什么用？当<code>float:right</code>时不就能清除右侧浮动了么！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;clear用于解决，由于float造成的浮动塌陷问题。&lt;/p&gt;
&lt;h2 id=&quot;只能清除前面的浮动&quot;&gt;&lt;a href=&quot;#只能清除前面的浮动</summary>
      
    
    
    
    <category term="CSS" scheme="https://zxffan.github.io/categories/CSS/"/>
    
    
    <category term="css" scheme="https://zxffan.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="https://zxffan.github.io/posts/616f4683.html"/>
    <id>https://zxffan.github.io/posts/616f4683.html</id>
    <published>2021-05-17T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能优化是很大的话题，可以从两个角度入手</p><ul><li>优化资源体积</li><li>优化请求速度</li></ul><h2 id="优化资源体积"><a href="#优化资源体积" class="headerlink" title="优化资源体积"></a>优化资源体积</h2><h3 id="资源懒加载"><a href="#资源懒加载" class="headerlink" title="资源懒加载"></a>资源懒加载</h3><p>资源懒加载就是指，当前这个页面只去加载本页面的资源。其它资源不去加载</p><h4 id="按照路由懒加载"><a href="#按照路由懒加载" class="headerlink" title="按照路由懒加载"></a>按照路由懒加载</h4><p>如果使用<code>webpack</code>这种构建工具，可以使用动态<code>import</code>函数来按照路由实现拆分chunk</p><h4 id="拆分node-modules"><a href="#拆分node-modules" class="headerlink" title="拆分node_modules"></a>拆分node_modules</h4><p>如果一个项目使用到了诸如：<code>element-ui</code> <code>vue</code> <code>pdfjs</code> <code>videojs</code>这些插件；<code>webpack</code>默认会将所有<code>node_modules</code>打包成一个<code>chunk</code>。但是某一个页面只用到了vue没有用到其它库，这是就会导致这个页面加载了许多无用的资源</p><p>所以我们要根据使用情况来拆分<code>node_modules</code>。具体做法就是通过<code>webpack</code>的<code>splitChunk</code>功能来实现。</p><blockquote><p>把这些库都拆分出去了，不就影响到下个页面的性能的吗？</p><p>利用<code>preftch</code>解决</p><ul><li>import函数可以使用魔法注释 <code>/*.webpackPrefetch: true */</code> <code>/*.webpackPreload: true */</code></li></ul></blockquote><h4 id="库按需加载"><a href="#库按需加载" class="headerlink" title="库按需加载"></a>库按需加载</h4><p>比如<code>element-ui</code>，它内置了大量组件。我们应该去按需引用他们。</p><p>使用<code>babel-plugin-import</code>来实现组件库（js和css）的按需加载</p><h3 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h3><h4 id="客户端压缩"><a href="#客户端压缩" class="headerlink" title="客户端压缩"></a>客户端压缩</h4><p>客户端压缩资源文件，比如<code>js</code> <code>css</code> <code>img</code>等</p><ul><li>js：使用<code>terser-webpack-plugin</code>压缩脚本代码</li><li>css：使用<code>optimize-css-webpack-plugin</code></li><li>Img: 图片可以使用 <code>image-webpack-loader</code>压缩</li></ul><h4 id="服务端压缩"><a href="#服务端压缩" class="headerlink" title="服务端压缩"></a>服务端压缩</h4><p>服务端开启<code>g-zip</code>压缩</p><p>比如nginx，直接配置<code>gzip: on</code>即可</p><h2 id="优化请求速度"><a href="#优化请求速度" class="headerlink" title="优化请求速度"></a>优化请求速度</h2><p>从请求速度角度入手。首先，需要理清楚页面显示之前都发生了些什么。</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>输入url，后首先不是DNS，而是检查浏览器缓存。浏览器缓存可以分成四种</p><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p><code>service worder</code>就是服务端与客户端之间的代理人。客户端对资源的请求会被<code>service worker</code>拦截下来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="comment">/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;install&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */</span></span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    <span class="comment">/* 创建一个名叫V1的缓存版本 */</span></span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="comment">/* 指定要缓存的内容，地址为相对于跟域名的访问路径 */</span></span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">addAll</span>([</span><br><span class="line">        <span class="string">&#x27;./index.html&#x27;</span> <span class="comment">// 资源URL</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册fetch事件，拦截全站的请求 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 在缓存中匹配对应请求资源直接返回 */</span></span><br><span class="line">  event.<span class="title function_">respondWith</span>(caches.<span class="title function_">match</span>(event.<span class="property">request</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>service worker</code>需要注册, <code>navigator.serviceWorker.register</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">/* 判断当前浏览器是否支持serviceWorker */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">/* 当页面加载完成就创建一个serviceWorker */</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* 创建并指定对应的执行内容 */</span></span><br><span class="line">    <span class="comment">/* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 &#x27;/&#x27;，表示 根网域下的所有内容。这也是默认值。 */</span></span><br><span class="line">    navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;./&#x27;</span>&#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">registration</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.<span class="property">scope</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ServiceWorker registration failed: &#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>service worker是基于web worker</p></blockquote><h4 id="memory-cache-disk-cache"><a href="#memory-cache-disk-cache" class="headerlink" title="memory cache &amp; disk cache"></a>memory cache &amp; disk cache</h4><ul><li><p>内存缓存，这部分资源存放到内存中的</p></li><li><p>磁盘缓存，这部分资源是存放到磁盘中的。也就是我们常说的<strong>强缓存</strong>和<strong>协商缓存</strong></p></li></ul><p><code>chrome</code>会自动将磁盘缓存存放到内存中，下次请求时，就会自动从内存中去。内存IO的性能肯定优于磁盘IO。当浏览器关闭后，存放到内存的缓存就会自动清空，而磁盘缓存一致存在</p><h4 id="push-cache"><a href="#push-cache" class="headerlink" title="push cache"></a>push cache</h4><p><code>HTTP2</code>拥有<strong>服务端推送的功能</strong>。</p><h3 id="DNS-prefetch"><a href="#DNS-prefetch" class="headerlink" title="DNS prefetch"></a>DNS prefetch</h3><p>开启DNS 预取，在加载HTML时，开始解析域名获取IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会自动加上响应头，告诉浏览器开始dns预解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定要解析的域名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//www.zhix.net&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>将一些图片或者不变的大资源，采用CDN上云的方式。从而加快请求速度</p><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>现代浏览器对同一个域的请求是有并发限制的。比如<code>chrome</code>最多并发6个请求。我们有两种方案来解决：</p><ul><li>拆分不同的域名：那我们可以将资源拆分到不同的域下，从而绕开限制。</li><li>使用HTTP2：<code>http2</code>可以实现多路复用，一个域名只需要建立一个tcp连接</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h2&gt;&lt;p&gt;性能优化是很大的话题，可以从两个角度入手&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化资源体积&lt;/li&gt;
&lt;li&gt;优化请求速度&lt;/li&gt;
</summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="网络" scheme="https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Nodejs" scheme="https://zxffan.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuex@4.x</title>
    <link href="https://zxffan.github.io/posts/340f0a10.html"/>
    <id>https://zxffan.github.io/posts/340f0a10.html</id>
    <published>2021-05-12T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex注册流程"><a href="#Vuex注册流程" class="headerlink" title="Vuex注册流程"></a>Vuex注册流程</h2><p>首先通过<code>createStore</code>方法创建一个store对象。然后使用<code>app.use(store)</code>。<code>store</code>对象是一个vue插件。所以必须实现install方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  install (app, injectKey) &#123;</span><br><span class="line">    app.<span class="title function_">provide</span>(injectKey || storeKey, <span class="variable language_">this</span>)</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$store</span> = <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件里使用vuex</span></span><br><span class="line"><span class="comment">// 1: this.$store</span></span><br><span class="line"><span class="comment">// 2: inject: [injectKey] </span></span><br></pre></td></tr></table></figure><p>创建store对象的流程：</p><ol><li>初始化所有module</li><li>resetStoreState<ul><li>注册getter</li><li>响应式state</li></ul></li></ol><h2 id="如何注册module"><a href="#如何注册module" class="headerlink" title="如何注册module"></a>如何注册module</h2><p><code>installModule</code>会初始化root模块，也会初始化所有子模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span> (store, rootState, path, <span class="variable language_">module</span>, hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store.<span class="property">_modules</span>.<span class="title function_">getNamespace</span>(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">namespaced</span>) &#123;</span><br><span class="line">    store.<span class="property">_modulesNamespaceMap</span>[namespace] = <span class="variable language_">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = <span class="title function_">getNestedState</span>(rootState, path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = <span class="variable language_">module</span>.<span class="property">context</span> = <span class="title function_">makeLocalContext</span>(store, namespace, path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有mutation</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachMutation</span>(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    <span class="title function_">registerMutation</span>(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有action</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachAction</span>(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.<span class="property">root</span> ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.<span class="property">handler</span> || action</span><br><span class="line">    <span class="title function_">registerAction</span>(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有getter</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachGetter</span>(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    <span class="title function_">registerGetter</span>(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有子模块</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachChild</span>(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">installModule</span>(store, rootState, path.<span class="title function_">concat</span>(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册getters"><a href="#注册getters" class="headerlink" title="注册getters"></a>注册getters</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerGetter</span> (store, type, rawGetter, local) &#123;</span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">_wrappedGetters</span>[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把所有getter 注册到 _wrappedGetters对象上</span></span><br><span class="line">  store.<span class="property">_wrappedGetters</span>[type] = <span class="keyword">function</span> <span class="title function_">wrappedGetter</span> (store) &#123;</span><br><span class="line">    <span class="comment">// rawGetter就是开发者提供的getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">rawGetter</span>(</span><br><span class="line">      local.<span class="property">state</span>, <span class="comment">// local state</span></span><br><span class="line">      local.<span class="property">getters</span>, <span class="comment">// local getters</span></span><br><span class="line">      store.<span class="property">state</span>, <span class="comment">// root state</span></span><br><span class="line">      store.<span class="property">getters</span> <span class="comment">// root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册actions"><a href="#注册actions" class="headerlink" title="注册actions"></a>注册actions</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerAction</span> (store, type, handler, local) &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store.<span class="property">_actions</span>[type] || (store.<span class="property">_actions</span>[type] = [])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 利用闭包实现柯里化</span></span><br><span class="line">  <span class="comment">// 下次执行函数就不需要传参数了</span></span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedActionHandler</span> (payload) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.<span class="title function_">call</span>(store, &#123;</span><br><span class="line">      <span class="attr">dispatch</span>: local.<span class="property">dispatch</span>,</span><br><span class="line">      <span class="attr">commit</span>: local.<span class="property">commit</span>,</span><br><span class="line">      <span class="attr">getters</span>: local.<span class="property">getters</span>,</span><br><span class="line">      <span class="attr">state</span>: local.<span class="property">state</span>,</span><br><span class="line">      <span class="attr">rootGetters</span>: store.<span class="property">getters</span>,</span><br><span class="line">      <span class="attr">rootState</span>: store.<span class="property">state</span></span><br><span class="line">    &#125;, payload)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 会用Promise包一层 action</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isPromise</span>(res)) &#123;</span><br><span class="line">      res = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">_devtoolHook</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store.<span class="property">_devtoolHook</span>.<span class="title function_">emit</span>(<span class="string">&#x27;vuex:error&#x27;</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册mutations"><a href="#注册mutations" class="headerlink" title="注册mutations"></a>注册mutations</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerMutation</span> (store, type, handler, local) &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store.<span class="property">_mutations</span>[type] || (store.<span class="property">_mutations</span>[type] = [])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对各个模块 注册mutation</span></span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedMutationHandler</span> (payload) &#123;</span><br><span class="line">    handler.<span class="title function_">call</span>(store, local.<span class="property">state</span>, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何初始化store中的数据"><a href="#如何初始化store中的数据" class="headerlink" title="如何初始化store中的数据"></a>如何初始化store中的数据</h2><p>需要响应式的数据有getters和state</p><p>state的响应式是通过<code>reactive</code>对象来实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resetStoreState</span> (store, state, hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldState = store.<span class="property">_state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.<span class="property">getters</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// reset local getters cache</span></span><br><span class="line">  store.<span class="property">_makeLocalGettersCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store.<span class="property">_wrappedGetters</span></span><br><span class="line">  <span class="keyword">const</span> computedObj = &#123;&#125;</span><br><span class="line">  <span class="title function_">forEachValue</span>(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    computedObj[key] = <span class="title function_">partial</span>(fn, store)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(store.<span class="property">getters</span>, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> computedObj[key](),</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用reactive响应式state</span></span><br><span class="line">  store.<span class="property">_state</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: state</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new state</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">strict</span>) &#123;</span><br><span class="line">    <span class="title function_">enableStrictMode</span>(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        oldState.<span class="property">data</span> = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现只有mutation才能修改state"><a href="#如何实现只有mutation才能修改state" class="headerlink" title="如何实现只有mutation才能修改state"></a>如何实现只有mutation才能修改state</h2><p>说明：只有<strong>严格模式</strong>且<strong>开发模式</strong>下，vuex才会阻止非mutation修改state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式会调用 enableStrictMode</span></span><br><span class="line"><span class="keyword">if</span> (store.<span class="property">strict</span>) &#123;</span><br><span class="line">  <span class="title function_">enableStrictMode</span>(store)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用watch监听state，如果state发生变化</span></span><br><span class="line"><span class="comment">// 提示</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enableStrictMode</span> (store) &#123;</span><br><span class="line">  <span class="title function_">watch</span>(<span class="function">() =&gt;</span> store.<span class="property">_state</span>.<span class="property">data</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// assert如果条件为 false会抛一场</span></span><br><span class="line">      <span class="comment">// 由于是sync</span></span><br><span class="line">      <span class="comment">// 所以会阻止修改</span></span><br><span class="line">      <span class="title function_">assert</span>(store.<span class="property">_committing</span>, <span class="string">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">flush</span>: <span class="string">&#x27;sync&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个<code>store._committing</code>只要是<code>false</code>就会阻止修改state。</p><p>那什么时候这个值为true呢，那肯定是commit的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  entry.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">commitIterator</span> (handler) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// _withCommit方法会修改_committing的状态</span></span><br><span class="line"><span class="comment">// 执行完mutation又会 改回来</span></span><br><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="variable language_">this</span>.<span class="property">_committing</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_committing</span> = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex注册流程&quot;&gt;&lt;a href=&quot;#Vuex注册流程&quot; class=&quot;headerlink&quot; title=&quot;Vuex注册流程&quot;&gt;&lt;/a&gt;Vuex注册流程&lt;/h2&gt;&lt;p&gt;首先通过&lt;code&gt;createStore&lt;/code&gt;方法创建一个store对象。然后使用</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron的隔离上下文</title>
    <link href="https://zxffan.github.io/posts/b9b99d96.html"/>
    <id>https://zxffan.github.io/posts/b9b99d96.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ContextIsolation"><a href="#ContextIsolation" class="headerlink" title="ContextIsolation"></a>ContextIsolation</h2><p>处于安全考虑，<code>Electron12</code>默认开启了上下文隔离（context isolation），它会将<strong>上下文环境</strong>划分两个运行环境——<strong>主环境</strong>和<strong>隔离环境</strong></p><p>主环境：渲染进程所运行的环境，无法访问到Electron API</p><p>隔离环境：preload脚本所运行的环境，能够访问到Electron API</p><p><code>ContextIsolation</code>是默认开启的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">  <span class="attr">webPreference</span>: &#123;</span><br><span class="line">    <span class="attr">contextIsolation</span>: <span class="literal">true</span> <span class="comment">// 默认就是true</span></span><br><span class="line">    <span class="attr">preload</span>: <span class="string">&#x27;path to your preload js file&#x27;</span>, <span class="comment">// 设置preload脚本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ContextBridge"><a href="#ContextBridge" class="headerlink" title="ContextBridge"></a>ContextBridge</h2><p>通过使用<a href="https://www.electronjs.org/docs/api/context-bridge#contextbridgeexposeinmainworldapikey-api-experimental">ContextBridge</a>，可以通过隔离环境将<code>Electron API</code>暴露给主环境</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隔离环境</span></span><br><span class="line"><span class="keyword">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">contextBridge.<span class="title function_">exposeInMainWorld</span>(</span><br><span class="line">  <span class="string">&#x27;electron&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">doThing</span>: <span class="function">() =&gt;</span> ipcRenderer.<span class="title function_">send</span>(<span class="string">&#x27;do-a-thing&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>主环境直接在window对象上使用<code>window.electron.doThing()</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ContextIsolation&quot;&gt;&lt;a href=&quot;#ContextIsolation&quot; class=&quot;headerlink&quot; title=&quot;ContextIsolation&quot;&gt;&lt;/a&gt;ContextIsolation&lt;/h2&gt;&lt;p&gt;处于安全考虑，&lt;code&gt;E</summary>
      
    
    
    
    <category term="Electron" scheme="https://zxffan.github.io/categories/Electron/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="Electron" scheme="https://zxffan.github.io/tags/Electron/"/>
    
    <category term="桌面端软件" scheme="https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vue-router@4.x</title>
    <link href="https://zxffan.github.io/posts/22412f62.html"/>
    <id>https://zxffan.github.io/posts/22412f62.html</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="vue-router是如何实现修改url而不会使页面刷新？"><a href="#vue-router是如何实现修改url而不会使页面刷新？" class="headerlink" title="vue-router是如何实现修改url而不会使页面刷新？"></a>vue-router是如何实现修改url而不会使页面刷新？</h3><p><code>vue-router</code>通过<code>history</code>这个<code>BOM</code>对象来修改url的</p><ul><li><code>history.pushState</code>：向当前浏览器会话的历史堆栈中添加一个state</li><li><code>history.replaceState</code>：替换历史堆栈栈顶的state</li></ul><p>这两个API不会导致页面刷新</p><h3 id="vue-router如何监听url变化？"><a href="#vue-router如何监听url变化？" class="headerlink" title="vue-router如何监听url变化？"></a>vue-router如何监听url变化？</h3><p><code>history.pushState</code>和<code>history.replaceState</code>是手动执行的，不需要监听</p><p>需要监听浏览器后退——<code>window.addEventListener(&quot;popstate&quot;, () =&gt; &#123;&#125;)</code></p><blockquote><p>旧版本的<code>vue-router</code>。对hash路由做了一层兼容性判断：如果浏览器支持<code>history.pushState</code>就监听<code>popstate</code>事件，否则监听<code>hashchange</code></p></blockquote><h3 id="vue-router的路由组件如何响应url变化"><a href="#vue-router的路由组件如何响应url变化" class="headerlink" title="vue-router的路由组件如何响应url变化"></a>vue-router的路由组件如何响应url变化</h3><p>在执行<code>vue-router</code>的<code>install</code>方法时，将<code>currentRoute</code>全局注入（provide），然后在<code>router-view</code>组件内<code>inject</code>。</p><p>在创建router时传入了<code>routes</code>参数，以定义应用的路由列表。<code>routes</code>是一个树结构。每一次路由变化时，都会在routes中寻找一个匹配当前跳转url的路由列表（数组）并赋值给<code>currentRoute.matched</code>。</p><p>在<code>router-view</code>中时这样获取的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matchedRouteRef = computed&lt;<span class="title class_">RouteLocationMatched</span> | <span class="literal">undefined</span>&gt;(</span><br><span class="line">  <span class="function">() =&gt;</span> routeToDisplay.<span class="property">value</span>.<span class="property">matched</span>[depth]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>router-view</code>是一个嵌套结构，<code>depth</code>表示深度。<code>depth</code>是这样来的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depth = <span class="title function_">inject</span>(viewDepthKey, <span class="number">0</span>) <span class="comment">// 初始默认为0</span></span><br><span class="line"><span class="title function_">provide</span>(viewDepthKey, depth + <span class="number">1</span>) <span class="comment">// +1 provide给子组件</span></span><br></pre></td></tr></table></figure><p>这样就可以获取匹配到的路由，然后就是获取路由对应的组件，并渲染。</p><h3 id="导航守卫原理"><a href="#导航守卫原理" class="headerlink" title="导航守卫原理"></a>导航守卫原理</h3><p>每次发生路由跳转时，回去执行导航守卫，源码位于<code>vue-router-next/src/router.ts</code>下的<code>navigate</code>方法。该方法主要做了：</p><ol><li>收集<code>beforeRouteLeave</code>导航守卫</li><li>执行所有收集到的导航</li><li>收集并执行全局守卫<code>beforeEach</code></li><li>收集并执行<code>beforeRouteUpdate</code></li><li>收集并执行<code>beforeEnter</code></li><li>收集并执行<code>beforeRouteEnter</code></li><li>收集并执行<code>beforeResolve</code></li><li>最后执行<code>afterEach</code></li></ol><blockquote><p>整个过程是Promise链式调用。若其中一步reject，后面就不会执行了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;h3 id=&quot;vue-router是如何实现修改url而不会使页面刷新？&quot;&gt;&lt;a href=&quot;#vue-router是如何实现修改url而不会使</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>网络知识梳理</title>
    <link href="https://zxffan.github.io/posts/8c9e2fd.html"/>
    <id>https://zxffan.github.io/posts/8c9e2fd.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP演进"><a href="#HTTP演进" class="headerlink" title="HTTP演进"></a>HTTP演进</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>第一版HTTP协议，只能传输文本，请求报文内容只有 1 行。</p><ul><li>客户端：请求报文：<code>GET/index.html</code></li><li>服务端：返回一个以 ASCII 字符流编码的 HTML 文档。</li></ul><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>HTTP 可以用来传输脚本、样式、图片、音频和视频等不同类型的文件</p><p>增加了头部的设定，<code>Accept</code>和<code>Content-Type</code></p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>解决了<code>HTTP/1.0</code>的连接问题，支持TCP连接复用</p><ul><li><code>HTTP/1.0</code>：每次请求都会建立连接、传输数据和断开连接三个阶段</li><li><code>HTTP/1.1</code>：第二次请求会复用第一次请求的TCP连接</li></ul><p>长连接可以在请求头中加上<code>Connection: keep-alive</code>。<code>HTTP/1.1</code>默认开启<code>keep-alive</code>，不加这个请求头也可以使用长连接的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p><code>HTTP/2</code>增强了并发能力</p><ul><li><strong>二进制传输</strong>：<code>http/1.1</code>传输的是文本，<code>http/2</code>传输的是二进制流</li><li><strong>多路复用</strong>：<code>http/2</code>有两个概念——<strong>帧</strong>和<strong>流</strong>。<code>http/2</code>将数据报文分成一个个二进制<strong>帧（Frame）</strong>，在一个TCP连接中，不同的帧组合在一起发送（<strong>二进制分帧</strong>）形成<strong>流（Stream）</strong>。在接收方根据帧首部信息在组合起来。<code>HTTP/1.1</code>只能一个个请求报文排队发送（容易发生<strong>队头阻塞</strong>）。</li><li><strong>header压缩</strong>：http请求有这繁多冗长的首部，<code>http/2</code>会对首部进行压缩</li><li><strong>服务端推送</strong>：能够主动给客户端推送资源<ul><li><code>http/1.1</code>加载网页的顺序：请求html，解析html，再请求js、css等文件</li><li><code>http/2</code>：当服务端收到html请求时，服务端就主动吧html、css、js以及图片等资源发送给客户端</li></ul></li></ul><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p><code>HTTP/1.x</code>、<code>HTTPS</code>以及<code>HTTP/2.0</code>都离不开底层的<code>TCP</code>协议。</p><p><code>HTTP/2.0</code>采用多路复用，多个数据包使用一个<code>TCP</code>连接。<code>TCP</code>是可靠连接，但发生丢包时，会进行重传。所以网络状态差的情况下，某些数据包频繁重传，从而导致拥塞，后面的HTTP包都穿不出去。这叫做<strong>头部阻塞（Head of line Blocking）</strong></p><p><code>HTTP/3.0</code>就开始考虑放弃<code>TCP</code>转向<code>UDP</code>协议。起初<code>Google</code>搞出来个<code>QUIC</code>协议，后来<code>IETF</code>标准化了<code>QUIC</code>协议形成<code>HTTP/3</code>。其底层采用<code>UDP</code>，基于<code>UDP</code>实现做了众多增强：</p><ul><li>0RTT：<code>TPC</code>建立连接每次都需要三次握手，就存在数据包的三次往返即<strong>3RTT</strong>。而<code>QUIC</code>首次建立连接只需要<code>1RTT</code>。其后的连接可以直接复用，只需要<strong>0RTT</strong></li><li>连接迁移：当<code>源IP</code>、<code>源端口</code>、<code>目的IP</code>、<code>目的端口</code>其中一个发生变化就需要重新建立TCP连接。只要<strong>Connection ID</strong>没有变化。<code>HTTP/3</code>可以继续复用连接</li><li>头部阻塞：由于使用<code>UDP</code>，发生丢包时，也不会立即重传，阻塞连接。</li><li>拥塞控制</li><li>前向纠错</li><li>更多特性 请参考<a href="https://zhuanlan.zhihu.com/p/143464334">文章</a></li></ul><p>chrome只支持 <code>Google QUIC</code>。对<code>IETF QUIC</code>的支持处于<code>WIP</code>状态</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP(超文本传输协议)，有着一个致命的缺陷，那就是内容是<strong>明文传输</strong>的，没有经过任何加密，而这些明文数据会经过<strong>WiFi、路由器、运营商、机房</strong>等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做MITM（Man In The Middle）<strong>中间人攻击</strong>。</p><p>HTTPS &#x3D; HTTP + TLS&#x2F;SSL。HTTPS就是在HTTP（应用层）与TCP（传输层）之间加上了一层<code>TLS/SSL</code>协议</p><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>区别：</p><ul><li>加解密方式不同：<ul><li>对称加密使用同一个密钥加解密</li><li>非对称加密使用不同的密钥加解密</li></ul></li><li>性能：对称加密比非对称加密快</li></ul><h3 id="CA-Certification-Authority"><a href="#CA-Certification-Authority" class="headerlink" title="CA(Certification Authority)"></a>CA(Certification Authority)</h3><p>CA是为了保证密钥的正确性。具体来说就是把密钥放入一个证书中，该证书包含服务端的信息，比如颁发者、域名、有效期，为了保证证书是可信的，需要由一个可信的第三方来对证书进行签名。这个第三方一般是证书的颁发机构，也称 CA（Certification Authority，认证中心）。</p><h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h3><p><img src="/../../images/network/HTTP-process.webp" alt="https"></p><ol><li>客户端发送HTTPS请求（默认端口443）</li><li>服务端有一套<code>CA数字证书</code>，证书含有一个<code>公钥public</code>。服务端接收到请求，会将这个证书发送给客户端。服务端还有一个<code>私钥private</code>，私钥是一直保存再服务端不公开的。</li><li>客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续。</li><li>客户端先生成一段<code>随机key</code>，再利用证书中的<code>公钥public</code>加密这段<code>随机key</code>，并将这个<code>随机key密文</code>发送给服务端。</li><li>服务端收到这个<code>随机key密文</code>文后，通过<code>私钥private</code>来解密，获取客户端真正的<code>随机key</code></li><li>服务端使用<code>随机key</code>来加密需要传输的HTTP数据，并发送给客户端</li><li>客户端再用<code>随机key</code>来解密服务端传输过来的密文，获取真正的数据</li><li>后续HTTPS请求使用之前交换好的<code>随机Key</code>进行对称加解密。</li></ol><blockquote><p> 由于随机key明文没有再网络上传输，所以”中间人”并不知道用于加密和解密的随机key，因此是安全的</p></blockquote><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><code>SYN</code>报文：请求连接</p><p><code>ACK</code>报文：应答</p><p><code>FIN</code>报文：断开连接</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手就是建立TCP连接的过程，流程如下图：</p><p><img src="/../../images/network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p>一共分三步：</p><ol><li>客户端发送SYN消息给服务端（告知服务端要建立连接）</li><li>服务端同时发送两个消息（SYN和ACK）给客户端<ul><li>ACK表示收到了客户端的SYN</li><li>SYN表示服务端也要连接客户端</li></ul></li><li>客户端发送ACK给服务端（表示接受服务端的SYN）</li></ol><blockquote><p> <strong>为什么要三次握手？</strong></p><p>TCP是可靠传输，三次握手目的是确认双方的接收和发送能力。经过三次握手，服务端和客户端都确认了双方的接收和发送能力。</p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手是TCP断开连接的过程，流程如下图</p><p><img src="/../../images/network/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手.png"></p><p>一共分为四步：（客户端和服务端都可以断开请求，以服务端为例）</p><ol><li>服务端发送FIN请求，表示服务端要断开连接</li><li>客户端发送ACK请求，表示收到了服务端的请求</li><li>客户单发送FIN请求，表示客户端也要断开连接</li><li>服务端发送ACK请求，表示收到了客户端的请求</li></ol><blockquote><p>为什么2，3步骤不能一起发送</p><p>ACK只是对FIN的应答，断开连接要处理的问题比较多，比如说服务端&#x2F;客户端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。</p></blockquote><h2 id="webscoket"><a href="#webscoket" class="headerlink" title="webscoket"></a>webscoket</h2><p><code>websocket</code>的建立也是通过<code>http</code>实现的</p><p>首先，客户端先发送一个HTTP请求，请求头携带以下信息</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">ws://websocket.example.com/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>websocket.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line">Sec-WebSocket-Key:pAloKxsGSHtpIHrJdWLvzQ==</span><br><span class="line">Sec-WebSocket-Version:13</span><br></pre></td></tr></table></figure><ul><li><code>Connection: Upgrade</code>告知服务端，浏览器想要升级协议</li><li><code>Upgrade: websocket</code>：升级到websocket协议</li><li><code>Sec-WebSocket-Key</code>浏览器的随机key，用于娇艳</li><li><code>Sec-WebSocket-Version</code>：websocket版本</li></ul><p>服务端收到请求，就开始升级协议，返回101。服务端收到。响应大概是这样的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>nRu4KAPUPjjWYrnzxDVeqOxCvlM=</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Accept</code>是根据响应头中的key进行加密而来的</p><p>客户端收到这个响应后，会校验这个<code>accept</code>。就是以同样的方式加密key，看key和accept是否相同。</p><p>到这里，websocket的连接就建立完成了。随后的请求都是以websocket协议发送。</p><h2 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h2><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p><code>TCP/IP</code>是互联网相关的各类协议族的总称<br><code>TCP/IP</code>具有分层结构，分为：应用层、传输层、网络层和数据链路层</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。<br>相关协议：<code>FTP</code>、<code>DNS</code>以及<code>HTTP</code></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层提供处于网络连接中的两台计算机之间的数据传输<br>相关协议：<code>TCP</code>和<code>UDP</code></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层规定了数据包通过怎样的传输线路到达对方计算机<br>相关协议：<code>IP</code></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路是用来处理连接网络的<strong>硬件部分</strong><br>例如：<code>NIC(网卡)</code>、<code>光纤</code>等物理可见部分</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li>应用层</li><li>表示层：负责数据格式的转换</li><li>会话层：负责建立和断开通信连接</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p><img src="/../../images/network/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.webp" alt="网络分层结构"></p><h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层主要有3种功能：</p><ul><li>封装成帧：将物理层上交的比特流封装成帧</li><li>透明传输：封装成帧的时候，会给每个帧加上帧开始符（SOH）和帧结束符（EOT）。是指该层上传输的数据的内容、格式及编码没有限制，也没有必要解释信息结构的意义</li><li>差错检测<ul><li>比特差错</li><li>帧 丢失&#x2F;重复&#x2F;失序</li></ul></li></ul><p>对于网络层，由于链路层的存在，而不需要关心物理层具体采用了那种传输介质和通信设备。</p><blockquote><p>网络层、数据链路层和物理层要关联理解。</p><p>假如A与B通信（在不同的网段中），实际上AB之间还有很多的物理设备（交换机、路由器）。物理设备之间是通过传输介质相连接，比如光纤、同轴电缆（这属于物理层）。</p><p>消息从A到B，需要经过一个个的网段，每个网段内都是通过mac地址来寻找下一个站点（数据链路层）。在公网上使用IP来寻找目的主机（网络层）</p></blockquote><h4 id="传输单元"><a href="#传输单元" class="headerlink" title="传输单元"></a>传输单元</h4><p>物理层的 数据传输单元是数据位（bit）<br>数据链路层的数据传输单元是数据帧（frame）<br>网络层的数据传输单元是数据包（packet）<br>传输层的 数据传输单元是数据段（segment）<br>其他更高层次的数据传输单元是数据（data）</p><h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><table><thead><tr><th align="left"></th><th align="left">UDP</th><th>TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td>面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td>面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP演进&quot;&gt;&lt;a href=&quot;#HTTP演进&quot; class=&quot;headerlink&quot; title=&quot;HTTP演进&quot;&gt;&lt;/a&gt;HTTP演进&lt;/h2&gt;&lt;h3 id=&quot;HTTP-0-9&quot;&gt;&lt;a href=&quot;#HTTP-0-9&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="NetWork" scheme="https://zxffan.github.io/categories/NetWork/"/>
    
    
    <category term="NetWork" scheme="https://zxffan.github.io/tags/NetWork/"/>
    
    <category term="HTTP" scheme="https://zxffan.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型污染</title>
    <link href="https://zxffan.github.io/posts/54b3fc67.html"/>
    <id>https://zxffan.github.io/posts/54b3fc67.html</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型污染"><a href="#原型污染" class="headerlink" title="原型污染"></a>原型污染</h2><blockquote><p>原型污染就是，通过某种手段达到修改JavaScript原型的目的</p></blockquote><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br></pre></td></tr></table></figure><p>定义了一个对象a，a有一个<code>constructor</code>属性指向a的构造器（<code>Object</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">constructor</span> === <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object很常用，比如：<code>Object.prototype.toString</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a) <span class="comment">// &quot;[object Object]&quot; 获取类型</span></span><br></pre></td></tr></table></figure><p>但是问题来了，通过a对象可以访问并修改Object对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;attack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再使用 toString</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a) <span class="comment">// &quot;attack&quot;</span></span><br></pre></td></tr></table></figure><p>这就发生了<strong>原型污染</strong></p><blockquote><p>lodash发生过一次严重的原型污染bug，场景是两个对象合并<code>merge(a, b)</code>， </p></blockquote><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><h3 id="过滤危险属性"><a href="#过滤危险属性" class="headerlink" title="过滤危险属性"></a>过滤危险属性</h3><p>两个对象合并，把<code>constructor</code>属性和<code>__proto__</code>这样的敏感过滤掉。</p><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p><code>Object.freeze</code>可以冻结一个对象，这个对象不能被修改。</p><p>原理就是修改对象的<code>descriptor</code>中的<code>writable:false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="string">&quot;attack&quot;</span></span><br><span class="line"></span><br><span class="line">consoel.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>) <span class="comment">// ƒ toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-create-null"><a href="#Object-create-null" class="headerlink" title="Object.create(null)"></a>Object.create(null)</h3><p>创建一个原型对象为null的对象，这样就不存在污染原型的情况</p><h3 id="Map代替对象字面量"><a href="#Map代替对象字面量" class="headerlink" title="Map代替对象字面量"></a>Map代替对象字面量</h3><p><code>map.set(&quot;__proto__&quot;, xx)</code>并不会修改原型对象</p><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>深合并和深拷贝算法注意<strong>原型污染</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型污染&quot;&gt;&lt;a href=&quot;#原型污染&quot; class=&quot;headerlink&quot; title=&quot;原型污染&quot;&gt;&lt;/a&gt;原型污染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原型污染就是，通过某种手段达到修改JavaScript原型的目的&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="Promise" scheme="https://zxffan.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Webpack构建流程源码解析</title>
    <link href="https://zxffan.github.io/posts/aef11e42.html"/>
    <id>https://zxffan.github.io/posts/aef11e42.html</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.597Z</updated>
    
    <content type="html"><![CDATA[<p>webpack的构建分为3个阶段：</p><ul><li>准备阶段：生成 <code>compiler</code>和<code>compilation</code>对象</li><li>编译阶段：递归生成模块依赖图</li><li>产出阶段：优化modules，生成chunks。最终输出文件</li></ul><p>本文讨论的是<code>webpack@5.34.0</code></p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="创建compiler"><a href="#创建compiler" class="headerlink" title="创建compiler"></a>创建compiler</h3><p>对于每一个wepback的构建配置，都会创建一个<code>compiler</code>对象，记录着整个 Webpack 的生命周期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="title function_">webpack</span>(options)</span><br><span class="line"><span class="comment">// webpack(options, () =&gt; &#123;&#125;)</span></span><br></pre></td></tr></table></figure><p>调用webpack函数会返回<code>compiler</code>对象，其内部大致逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">webpack</span> = (<span class="params">options, callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 创建compiler</span></span><br><span class="line">  <span class="keyword">let</span> compiler;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(options)) compiler = <span class="title function_">createMultiCompiler</span>(options, options);</span><br><span class="line">  <span class="keyword">else</span> compiler = <span class="title function_">createCompiler</span>(options);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.</span></span><br><span class="line">  <span class="comment">// 有callback参数就会自动执行compiler.run</span></span><br><span class="line">  <span class="comment">// options中watch为true就会自动调用compiler.watch</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 返回compiler</span></span><br><span class="line">  <span class="keyword">return</span> compiler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例代码并非是webpack中的源码。只是将源码中的核心逻辑提炼出来的伪代码，这样更方便理解webpack的主流程。下同。</p></blockquote><p><code>createCompiler</code>和<code>createMultiCompiler</code>才是真正创建<code>compiler</code>的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createCompiler</span> = rawOptions =&gt; &#123;</span><br><span class="line"><span class="comment">// 1. normalize options</span></span><br><span class="line">  <span class="comment">// 就是对传入的options做些初始化，添加默认参数之类的工作</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 他来了，创建compiler对象</span></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>(options.<span class="property">context</span>);</span><br><span class="line">compiler.<span class="property">options</span> = options;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 新建NodeEvniromentPlugin，这是wepback启用的第一个plugin</span></span><br><span class="line">  <span class="comment">// 主要作用是 </span></span><br><span class="line">  <span class="comment">// - 创建日志（方便webpack输出构建日志）</span></span><br><span class="line">  <span class="comment">// - 设置compiler的文件系统 inputFileSystem...</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">NodeEnvironmentPlugin</span>(&#123;</span><br><span class="line"><span class="attr">infrastructureLogging</span>: options.<span class="property">infrastructureLogging</span></span><br><span class="line">&#125;).<span class="title function_">apply</span>(compiler);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 执行所有plugin</span></span><br><span class="line">  <span class="comment">// - 函数plugin，执行函数</span></span><br><span class="line">  <span class="comment">// - class plugin，执行其apply方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(options.<span class="property">plugins</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.<span class="property">plugins</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">plugin.<span class="title function_">call</span>(compiler, compiler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">plugin.<span class="title function_">apply</span>(compiler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">applyWebpackOptionsDefaults</span>(options);</span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">environment</span>.<span class="title function_">call</span>(); <span class="comment">// hook</span></span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">afterEnvironment</span>.<span class="title function_">call</span>(); <span class="comment">// hook</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5.添加默认内置plugin</span></span><br><span class="line">  <span class="comment">// 根据options的设置来配置响应内置plugin</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebpackOptionsApply</span>().<span class="title function_">process</span>(options, compiler); </span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">initialize</span>.<span class="title function_">call</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> compiler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createMultiCompiler</span> = (<span class="params">childOptions, options</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 给每一个option创建一个compiler</span></span><br><span class="line"><span class="keyword">const</span> compilers = childOptions.<span class="title function_">map</span>(<span class="function"><span class="params">options</span> =&gt;</span> <span class="title function_">createCompiler</span>(options));</span><br><span class="line">  <span class="comment">// 创建MultiCompiler对象</span></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="keyword">new</span> <span class="title class_">MultiCompiler</span>(compilers, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> compiler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里注意一点：在<code>compiler</code>对象创建后：</p><ol><li>逐一执行<code>options.plugins</code>中所有的plugin。</li><li>根据options的内容，添加webpack内置的plugin。比如<code>EntryOptionPlugin</code>。针对不同环境(node electron browser)会设置不同的plugin。</li></ol><blockquote><p>webpack有大量的内置plugin，这都是在<code>WebpackOptionsApply</code>中的<code>process</code>来设置的。可以说webpack的所有功能(resolve optimization module解析…)都是由相应的plugin完成的。</p></blockquote><p>获得<code>compiler</code>对象后，下一步就时进行构建，这是通过<code>compiler.run</code>方法实现的。</p><p><code>run</code>方法主要做了2件事：</p><ul><li>执行compiler的hook <code>beforeRun</code> <code>run</code> <code>readRecords</code>。在创建compiler对象时会执行所有plugin。如果在这三个hook绑定的了事件，在此时会被执行。（这三个hook时串行执行的，代码是嵌套的）</li><li>执行<code>compiler.compile</code>方法进行构建</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">beforeRun</span>.<span class="title function_">callAsync</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">finalCallback</span>(err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">callAsync</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">finalCallback</span>(err);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">readRecords</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">finalCallback</span>(err);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">compile</span>(onCompiled);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建Compilation"><a href="#创建Compilation" class="headerlink" title="创建Compilation"></a>创建Compilation</h3><p><code>compilation</code>对象属于<code>compiler</code>。每一次构建，<code>compiler</code>都会创建一个<code>compilation</code>对象</p><p><code>compiler.compile</code>方法会真正地创建<code>compilation</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./lib/Compiler.js</span></span><br><span class="line"><span class="comment">// compile</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="variable language_">this</span>.<span class="title function_">newCompilationParams</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">beforeCompile</span>.<span class="title function_">callAsync</span>(params, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">call</span>(params);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建compilation对象</span></span><br><span class="line">  <span class="keyword">const</span> compilation = <span class="variable language_">this</span>.<span class="title function_">newCompilation</span>(params);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 执行compiler的各种hook</span></span><br><span class="line">  <span class="comment">// 以及执行compilation的 finish 和 seal方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码很长，主要流程如下:</p><ol><li><code>compiler.hooks.beforeCompile</code> </li><li>创建<code>compilation</code>对象。这里调用了<code>compiler.newCompilation</code>方法，该方法做了以下几件事<ol><li>创建<code>compilation</code>，会先清理上一次构建的<code>compilation</code>对象</li><li><code>compiler.hooks.thisCompilation</code></li><li><code>compiler.hooks.compilation</code></li></ol></li><li><code>compiler.hooks.make</code> </li><li><code>compiler.hooks.finishMake</code></li><li><code>compilation.finish</code></li><li><code>compilation.seal</code></li><li><code>compiler.hooks.afterCompile</code></li></ol><p>这些hooks都是串行执行的。<code>afterCompile</code>这个hook的执行表示一次构建已经完成。那么从compilation对象创建完成到<code>afterCompile</code>触发之前，包含了<strong>编译阶段</strong>和<strong>产出阶段</strong></p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><code>compiler.hooks.make</code>这个hook被触发执行，就代表了编译开始。</p><p>在<code>compiler</code>创建时(<code>new WebpackOptionsApply().process(options, compiler); </code>)，这里给compiler添加了许多并绑定了许多内置plugin。其中有一个<code>EntryOptionsPlugin</code>，他是用于解析入口(entry)配置。根据entry字段类型再选择不同的plugin</p><ul><li>entry为function：<code>DynamicEntryPlugin</code></li><li>entry不为function：<code>EntryPlugin</code></li></ul><p>编译阶段的开始就是从<code>entry</code>文件开始解析<code>module</code>。</p><p>以<code>EntryPlugin</code>为例，其apply方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">make</span>.<span class="title function_">tapAsync</span>(<span class="string">&quot;EntryPlugin&quot;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; entry, options, context &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="title class_">EntryPlugin</span>.<span class="title function_">createDependency</span>(entry, options);</span><br><span class="line">  compilation.<span class="title function_">addEntry</span>(context, dep, options, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>EntryPlugin</code>在<code>compile.make</code>这个hook上注册了一个事件。<code>compiler.hooks.make</code>这个hook被触发执行时，hook上注册的事件全都会被执行。</p><p><code>EntryPlugin</code>会调用<code>compilation.addEntry</code>方法。</p><p>接下看就看<code>compilation</code>的表演：</p><ol><li>addEntry添加入口文件</li><li>将资源文件转成<code>NormalModule</code>对象（简称module对象），一个文件(js css img)都是一个module</li><li>调用<code>module.build</code>方法</li><li>调用<code>runLoaders</code>，找到相应的loader处理该module</li><li>对于js module，会通过<code>acorn</code>转成<code>AST</code>。分析模块依赖关系，如果有依赖模块 调用<code>compilation.addEntry</code>（第1步）</li><li>最终获取所有module</li></ol><blockquote><p>编译阶段是一个递归的过程</p><p>每一个module build完成都会触发<code>compilation.hooks.succeedModule</code>，并传入当前module对象</p></blockquote><h2 id="产出阶段"><a href="#产出阶段" class="headerlink" title="产出阶段"></a>产出阶段</h2><p>调用<code>compilation.seal</code>方法，封存文件就是处理文件生成chunk。</p><h3 id="Seal"><a href="#Seal" class="headerlink" title="Seal"></a>Seal</h3><p>首先触发<code>compilation.hooks.optimizeDependencies</code>这个hook上的所有事件。对module做一些优化操作（比如<code>tree-shaking</code>）</p><p>根据入口生成chunk，有几个入口就会有几个chunk。</p><p>然后就是递归分析chunk，如果有动态导入(<code>import()</code>)就会单独拆分出chunk</p><blockquote><p>这个过程还有一堆hooks，这些可以在这些hooks上做些优化操作。比如<code>optimizeModules</code>和<code>optimizeChunks</code></p></blockquote><p>生成chunck的<code>hash</code></p><p>生成chunk的<code>sourceMap</code></p><h3 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h3><p><code>createChunkAssets</code>生成assets ，会将生成的Assets存放到<code>compilation.assets</code>数组中</p><p><code>emitAsset</code>将文件输出</p><h2 id="Watch模式"><a href="#Watch模式" class="headerlink" title="Watch模式"></a>Watch模式</h2><p>当调用<code>compiler.watch</code>，会启用watch模式。当文件发生更改是，会自动重新构建.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">watch</span>(<span class="params">watchOptions, handler</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">watching</span> = <span class="keyword">new</span> <span class="title class_">Watching</span>(<span class="variable language_">this</span>, watchOptions, handler);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">watching</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch方法创建了一个<code>Watching</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watch</span> &#123;</span><br><span class="line">  <span class="title function_">contstructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_invalidate</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_invalidate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 防止重复构建</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_go</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_go</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构建逻辑</span></span><br><span class="line">    compiler.<span class="title function_">compile</span>() <span class="comment">// 调用compiler的compile方法进行构建</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_done</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构建完成了</span></span><br><span class="line">    <span class="comment">// 获取构建完后的依赖</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">watch</span>() <span class="comment">// 监听这些依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">watch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 监听文件变化</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">compiler</span>.<span class="property">watchFileSystem</span>.<span class="title function_">watch</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件发生变化 监听的回调会被调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_invalidate</span>() <span class="comment">// 进行下一轮构建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听文件是通过<code>this.compiler.watchFileSystem.watch()</code>方法来实现的。这个<code>watchFileSystem</code>是在创建<code>compiler</code>对象时，初始化的。</p><p>创建<code>compiler</code>时，执行了<code>NodeEvniromentPlugin</code>。这个plugin会设置文件系统。将<code>watchFleSystem</code>设置成<code>NodeWatchFileSystem</code>，而其内部又会创建一个<code>watchpack</code>对象来监听文件变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NodeEnvironmentPlugin</span> &#123;</span><br><span class="line"><span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">compiler.<span class="property">inputFileSystem</span> = <span class="keyword">new</span> <span class="title class_">CachedInputFileSystem</span>(fs, <span class="number">60000</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">compiler.<span class="property">watchFileSystem</span> = <span class="keyword">new</span> <span class="title class_">NodeWatchFileSystem</span>(</span><br><span class="line">compiler.<span class="property">inputFileSystem</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，当文件短时间变化多次，会触发多次构建吗？</p><p>其实是不会的，<code>watchpack</code>添加了防抖机制。只会触发最后一次。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一张图总结流程</p><p><img src="/../../images/framework/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.svg" alt="webpack构建流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webpack的构建分为3个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段：生成 &lt;code&gt;compiler&lt;/code&gt;和&lt;code&gt;compilation&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;编译阶段：递归生成模块依赖图&lt;/li&gt;
&lt;li&gt;产出阶段：优化modules，生</summary>
      
    
    
    
    <category term="工程化" scheme="https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="webpack" scheme="https://zxffan.github.io/tags/webpack/"/>
    
    <category term="架构" scheme="https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>vue2-生命周期</title>
    <link href="https://zxffan.github.io/posts/bdeefbce.html"/>
    <id>https://zxffan.github.io/posts/bdeefbce.html</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue2生命周期图"><a href="#Vue2生命周期图" class="headerlink" title="Vue2生命周期图"></a>Vue2生命周期图</h2><p><img src="/../../images/Vue/vue2%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B8%B2%E6%9F%93.svg" alt="生命周期"></p><h2 id="组件创建到页面渲染"><a href="#组件创建到页面渲染" class="headerlink" title="组件创建到页面渲染"></a>组件创建到页面渲染</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>new Vue()</code>的执行，会创建一个组件实例（根组件）<code>vm</code>，然后进行各种初始化工作</p><ol><li>合并 options，也就是初始化组件的options选项</li><li>初始化vm（组件实例）上的各个属性</li><li>初始化绑定在当前组件上的listener(v-on)</li><li>初始化render函数，在vm上绑定createElement方法</li><li>**<code>beforeCreated</code>**钩子调用</li><li>将inject定义为响应式</li><li>.初始化, 定义响应式数据 <code>props</code>  <code>methods</code> <code>data</code> <code> computed</code> <code>watch</code></li><li>初始化vm._provide属性</li><li>**<code>creted</code>**钩子调用</li></ol><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>如果<code>new Vue</code>传入了<code>el</code>属性，就会自动调用<code>vm.$mount</code>方法，渲染实例</p><ol><li>调用<code>mountComponent</code></li><li>新建Watcher，传入<code>updateComponent</code>逻辑</li><li>Watcher调用<code>updateComponent</code>逻辑</li><li>进入<code>patch</code>逻辑</li></ol><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>vue2的响应式涉及到三种角色——<code>reactiveObj(响应式对象)</code> <code>Watcher</code>  <code>Dep</code></p><ul><li>响应式对象通过<code>Object.defineProperty</code>拦截getter和setter</li><li>Watcher用于触发组件更新</li><li>每个响应式对象都有一个dep对象，它有一个subs的Watcher数组，用于记录依赖该响应式对象的所有watcher</li></ul><p>当组件开始渲染时：</p><ul><li>会创建一个<code>Watcher</code>对象。将组件更新的逻辑（<code>updateComponent</code>）记录到Watcher</li><li>将Dep.target设置为 创建的 <code>Watcher</code>对象</li></ul><p>随即执行render方法，会触发响应式对象的getter。将<code>Dep.target</code>添加到<code>dep.subs</code>中，即依赖收集</p><p>在修改响应式对象，会触发setter。</p><ul><li>执行<code>dep.notify</code>，触发<code>dpe.subs</code>中所有<code>watcher</code>的<code>update</code>方法</li><li><code>watcher.update()</code>会触发<code>updateComponent</code>，从而使得组件更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue2生命周期图&quot;&gt;&lt;a href=&quot;#Vue2生命周期图&quot; class=&quot;headerlink&quot; title=&quot;Vue2生命周期图&quot;&gt;&lt;/a&gt;Vue2生命周期图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/../../images/Vue/vue2%E4%BB%8E%</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack之SplitChunks</title>
    <link href="https://zxffan.github.io/posts/110bf707.html"/>
    <id>https://zxffan.github.io/posts/110bf707.html</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SplitChunks"><a href="#SplitChunks" class="headerlink" title="SplitChunks"></a>SplitChunks</h2><p><code>splitChunks</code>可以指定<code>webpack</code>打包的拆分规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;async&quot;</span>, <span class="comment">// 三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认)</span></span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">30000</span>, <span class="comment">// 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了</span></span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">0</span>, <span class="comment">// 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">// 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小</span></span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">5</span>, <span class="comment">// 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了</span></span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">3</span>, <span class="comment">// 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了</span></span><br><span class="line">      <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>, <span class="comment">// 打包文件名分隔符</span></span><br><span class="line">      <span class="attr">name</span>: <span class="literal">true</span>, <span class="comment">// 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vendors</span>: &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 正则规则，如果符合就提取 chunk</span></span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>, <span class="comment">// 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>, <span class="comment">// 优先级</span></span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>, <span class="comment">// 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用动态导入<code>import()</code>或者<code>requre.ensure()</code>，就会根据</p><h2 id="SplitChunks参数"><a href="#SplitChunks参数" class="headerlink" title="SplitChunks参数"></a>SplitChunks参数</h2><h3 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h3><p>有三个值——<code>async</code> <code>all</code> <code>initial</code></p><h4 id="async-默认"><a href="#async-默认" class="headerlink" title="async(默认)"></a>async(默认)</h4><p>只会将异步模块（<code>import()</code>导入的模块）提出出来</p><h4 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h4><p>提取同步模块和异步模块。如果一个模块在moduleA中是同步导入，在moduleB中是异步导入。那么由于导入方式不同，这个模块会被抽离出不同的文件。</p><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>提取同步模块和异步模块，无论是同步import还是异步import。都会抽离到一个文件中。<code>all</code>会最大程度复用文件。</p><h3 id="maxInitialRequests和maxAsyncRequests"><a href="#maxInitialRequests和maxAsyncRequests" class="headerlink" title="maxInitialRequests和maxAsyncRequests"></a>maxInitialRequests和maxAsyncRequests</h3><p>浏览器对相同域名的并法请求是有限制的。比如chrome 限制6个相同域名的请求。如果同一时间发送10个请求。则另外4个就会被阻塞</p><p>所以，<code>splitChunks</code>把文件拆得太碎，反而会影响加载时间。</p><p><code>maxInitialRequests</code>设置为<code>3</code>，表示浏览器初始最多发送3个请求。它会将入口文件拆成&lt;3份。</p><p><code>maxAsyncRequests</code>是用来限制异步模块并行最大请求数的。</p><blockquote><p>前者是限定入口的文件的拆分，后者是限定异步模块的拆分</p></blockquote><h3 id="minSize和maxSize"><a href="#minSize和maxSize" class="headerlink" title="minSize和maxSize"></a>minSize和maxSize</h3><p><code>minSize</code>：满足拆分的最小体积（单位字节）。大于这个大小并满足拆分规则就会被拆分</p><p><code>maxSize</code>：默认为0表示不作限制。如果非0。待拆分模块大小大于<code>maxSize</code>时就会拆分</p><blockquote><p>规则优先级：maxInitialRequest&#x2F;maxAsyncRequests &lt; maxSize &lt; minSize</p></blockquote><h3 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a>cacheGroups</h3><p>这是<code>splitChunks</code>最重要的部分。它定义了拆分规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">  <span class="attr">vendors</span>: &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 正则规则，如果符合就提取 chunk</span></span><br><span class="line">    <span class="attr">priority</span>: -<span class="number">10</span>, <span class="comment">// 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test</code>表示匹配规则，可以是一个正则。<code>/[\\/]node_modules[\\/]</code>表示匹配<code>/node_modules/</code>或着<code>\node_modules\</code></p><p><code>priority</code>：缓存组优先级，当一个模块可能属于多个 chunkGroup时，取优先级高的</p><p><code>reuseExistingChunk</code>: true表示复用其他chunk内已拥有的模块 当chunks引用了已经存在的被抽离的chunks时不会新创建一个chunk而是复用chunk。</p><p>其它属性：<code>chunks</code> <code>maxInitialRequests</code> <code>maxAsyncRequests</code> <code>minSize</code>…….</p><blockquote><p>cacheGroups下找不到<code>chunks</code>等属性，就会去splitChunks中的配置。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SplitChunks&quot;&gt;&lt;a href=&quot;#SplitChunks&quot; class=&quot;headerlink&quot; title=&quot;SplitChunks&quot;&gt;&lt;/a&gt;SplitChunks&lt;/h2&gt;&lt;p&gt;&lt;code&gt;splitChunks&lt;/code&gt;可以指定&lt;code&gt;</summary>
      
    
    
    
    <category term="工程化" scheme="https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="webpack" scheme="https://zxffan.github.io/tags/webpack/"/>
    
    <category term="架构" scheme="https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>web-vitals源码解读</title>
    <link href="https://zxffan.github.io/posts/473044000000.html"/>
    <id>https://zxffan.github.io/posts/473044000000.html</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-vitals简介"><a href="#web-vitals简介" class="headerlink" title="web-vitals简介"></a>web-vitals简介</h2><p><a href="https://www.npmjs.com/package/web-vitals#overview">web-vitals</a>是<code>google</code>开源的一个测量web性能指标的工具。体积才<strong>1KB</strong>，它可以用来测量<code>CLS</code>、<code>FID</code>、<code>LCP</code>、<code>FCP</code>、<code>TTFB</code>。</p><p>可通过npm来安装<code>npm install web-vitals</code></p><p>使用也十分简单</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getLCP, getFID, getCLS&#125; <span class="keyword">from</span> <span class="string">&#x27;web-vitals&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getCLS</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">getFID</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">getLCP</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><code>web-vitals</code>整个项目不是很复杂，目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─.git</span><br><span class="line">├─docs</span><br><span class="line">├─src # 源码</span><br><span class="line">├─test # 测试代码</span><br><span class="line">├─.eslintrc </span><br><span class="line">├─.gitignore</span><br><span class="line">├─base.d.ts</span><br><span class="line">├─base.js</span><br><span class="line">├─CHANGELOG.md</span><br><span class="line">├─LICENSE # 开源协议</span><br><span class="line">├─package-lock.json</span><br><span class="line">├─package.json</span><br><span class="line">├─README.md</span><br><span class="line">├─rollup.config.js # rollup构建配置</span><br><span class="line">├─tsconfig.json # ts配置</span><br><span class="line">├─wdio.conf.js # e2e测试配置</span><br></pre></td></tr></table></figure><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><p><code>web-vitals</code>通过配置eslint来约定代码规范。通常，<code>eslint</code>配置文件位于根目录下。这样对于整个项目都通用一套<code>eslint</code>配置。这往往是不满足需求的。可能src目录需要一套eslint配置，而test目录有需要另一套eslint配置。<code>web-vitals</code>是通过<code>eslintrc</code>下的<strong>overrides</strong>字段配置的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;babel-eslint&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;browser&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;es6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mocha&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wdio.conf.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span><span class="punctuation">,</span> <span class="string">&quot;google&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;max-len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;test/e2e/*.js&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;globals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;$&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;browser&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span><span class="punctuation">,</span> <span class="string">&quot;google&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;no-invalid-this&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max-len&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;ignorePattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^\\s*import|= require\\(|^\\s*it\\(|^\\s*describe\\(&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreUrls&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/**/*.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@typescript-eslint/parser&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;plugin:@typescript-eslint/recommended&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/no-non-null-assertion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/no-use-before-define&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/explicit-function-return-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/explicit-module-boundary-types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/ban-ts-comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/camelcase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;node/no-missing-import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;node/no-unsupported-features/es-syntax&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;node/no-missing-require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;node/shebang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;no-dupe-class-members&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;parserOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ecmaVersion&quot;</span><span class="punctuation">:</span> <span class="number">2018</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>overrides</code>字段对应的值是一个数组，该数组中的每个元素都是一条新的eslint规则，并覆盖全局配置</p><h3 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h3><p><a href="https://typicode.github.io/husky/"><code>husky</code></a>是一个<code>git</code>钩子工具，<code>package.json</code>文件下有个<code>husky</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint \&quot;*.js\&quot; \&quot;src/**/*.ts\&quot; \&quot;test/**/*.js\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lint:fix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix \&quot;*.js\&quot; \&quot;src/**/*.ts\&quot; \&quot;test/**/*.js\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;husky&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;pre-commit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>它的作用是，在每次<code>git commit</code>时，触发钩子并执行<code>npm run lint</code>，也就是进行Eslint检查。如果没有通过eslint，就会commit失败。</p><h3 id="rollup-plugin-eslint"><a href="#rollup-plugin-eslint" class="headerlink" title="@rollup&#x2F;plugin-eslint"></a>@rollup&#x2F;plugin-eslint</h3><p><code>web-vitals</code>的<code>rollup</code>并没有配置<a href="https://github.com/rollup/plugins/tree/master/packages/eslint">@rollup&#x2F;plugin-eslint</a>。如果加上这个插件，会在构建时进行eslint检查，如果没有通过eslint，就会构建失败并给出相应的修复提示。</p><h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><p><code>web-vitals</code>是通过<code>rollup</code>进行构建打包的。其配置也十分简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> replace <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-replace&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;terser&#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-babel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">configurePlugins</span> = (<span class="params">&#123;<span class="variable language_">module</span>, polyfill = <span class="literal">false</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [[<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">targets</span>: &#123;</span><br><span class="line">          <span class="attr">browsers</span>: [<span class="string">&#x27;ie 11&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;]],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">terser</span>(&#123;</span><br><span class="line">      <span class="variable language_">module</span>,</span><br><span class="line">      <span class="attr">mangle</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">replace</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;self.__WEB_VITALS_POLYFILL__&#x27;</span>: polyfill,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configs = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;esm&#x27;</span>,</span><br><span class="line">      <span class="attr">file</span>: <span class="string">&#x27;./dist/web-vitals.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">configurePlugins</span>(&#123;<span class="attr">module</span>: <span class="literal">true</span>, <span class="attr">polyfill</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      <span class="attr">file</span>: <span class="string">`./dist/web-vitals.umd.js`</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">configurePlugins</span>(&#123;<span class="attr">module</span>: <span class="literal">false</span>, <span class="attr">polyfill</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;esm&#x27;</span>,</span><br><span class="line">      <span class="attr">file</span>: <span class="string">&#x27;./dist/web-vitals.base.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">configurePlugins</span>(&#123;<span class="attr">module</span>: <span class="literal">true</span>, <span class="attr">polyfill</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      <span class="attr">file</span>: <span class="string">`./dist/web-vitals.base.umd.js`</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">      <span class="attr">extend</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">configurePlugins</span>(&#123;<span class="attr">module</span>: <span class="literal">false</span>, <span class="attr">polyfill</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;dist/modules/polyfill.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;iife&#x27;</span>,</span><br><span class="line">      <span class="attr">file</span>: <span class="string">&#x27;./dist/polyfill.js&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">      <span class="attr">strict</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">configurePlugins</span>(&#123;<span class="attr">module</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configs;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不同的产出文件"><a href="#不同的产出文件" class="headerlink" title="不同的产出文件"></a>不同的产出文件</h3><p>导出的<code>config</code>是一个数组。每个数组元素是一份rollup配置</p><table><thead><tr><th>产出文件名</th><th>module</th><th>polyfill</th></tr></thead><tbody><tr><td>web-vitals.js</td><td>esm</td><td>不含</td></tr><tr><td>web-vitals.umd.js</td><td>umd</td><td>不含</td></tr><tr><td>web-vitals.base.js</td><td>esm</td><td>含</td></tr><tr><td>web-vitals.base.umd.js</td><td>umd</td><td>含</td></tr><tr><td>polyfill.js</td><td>iife</td><td>-</td></tr></tbody></table><ul><li><p><code>esm</code>：即 ES Module，在代码中直接<code>import</code>使用</p></li><li><p><code>iife</code>：立即执行函数，就是<code>(function() &#123;&#125;)(window)</code>这种形式</p></li><li><p><code>umd</code>：本质上也是iife，但是它将待执行的函数作为iife的参数传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"> def </span>) &#123;</span><br><span class="line">  <span class="title function_">def</span>( <span class="variable language_">window</span> );</span><br><span class="line">&#125;)(<span class="keyword">function</span> <span class="title function_">def</span>(<span class="params"> <span class="variable language_">global</span> </span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 3 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">global</span>.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><code>iife</code>和<code>umd</code>都是直接在浏览器中使用了</p><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>rolup使用了<code>@rollup/plugin-replace</code>，用于替换一些常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">replace</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;self.__WEB_VITALS_POLYFILL__&#x27;</span>: polyfill,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这会将代码中所有出现的<code>self.__WEB_VITALS_POLYFILL__</code>的地方替换成<code>polyfill</code>变量的对应的值（<code>true</code>或<code>false</code>）。在代码中出现大量的<code>self.__WEB_VITALS_POLYFILL__</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib/getFirstHidden.ts </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function getFirstHidden</span></span><br><span class="line"><span class="keyword">if</span> (self.<span class="property">__WEB_VITALS_POLYFILL__</span>) &#123;</span><br><span class="line">    firstHiddenTime = self.<span class="property">webVitals</span>.<span class="property">firstHiddenTime</span>;</span><br><span class="line">    <span class="keyword">if</span> (firstHiddenTime === <span class="title class_">Infinity</span>) &#123;</span><br><span class="line">        <span class="title function_">trackChanges</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    firstHiddenTime = <span class="title function_">initHiddenTime</span>();</span><br><span class="line">    <span class="title function_">trackChanges</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>self.__WEB_VITALS_POLYFILL__</code>是true，rollup在构建时，就会吧else的逻辑删掉。反之，会把if的逻辑给删掉。这样就实现了Tree Shaking——删除多余代码。</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p><code>web-vitals</code>的源码是使用TS编写的，最终需要生成js文件。</p><p><code>web-vitals</code>的构建过程：</p><ul><li>先通过tsc生成<strong>js文件</strong>和<strong>类型声明文件</strong>。</li><li>再通过<strong>rollup</strong>进行对<strong>js文件</strong>打包构建</li></ul><p>类型声明需要再<code>package.json</code>中<code>typings</code>字段指定声明文件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/web-vitals.umd.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/web-vitals.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typings&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/modules/index.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;base.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;base.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;dist&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;src&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>main</code>:  定义了 npm 包的入口文件，browser 环境和 node 环境均可使用</p></li><li><p><code>module</code>:  定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用</p></li><li><p>好有个<code>browser</code> : 定义 npm 包在 browser 环境下的入口文件</p></li><li><p><code>files</code>：当<code>npm publish</code>是，指定需要上传的文件。</p></li></ul><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p><code>web-vitals</code>采用<code>Apache-2.0</code>开源协议。该协议允许开发者修改代码，并且商业发布。但是对于改动部分必须提供一份声明。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>web-vitals</code>的测试需要真实的浏览器环境，即需要<strong>端到端测试（e2e test）</strong>。项目通过[wdio（webDriver.IO）](<a href="https://webdriver.io/docs/gettingstarted">Getting Started | WebdriverIO</a>)来实现的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm-run-all build -p -r test:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;test:e2e&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wdio wdio.conf.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;test:server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node test/server.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>当执行<code>npm run test</code>时</p><ul><li>先构建打包项目</li><li>启动一个HTTP服务，用于处理浏览器的资源请求</li><li>启动wdio测试</li></ul><p>当执行test&#x2F;e2e目录下的测试用例时，例如<code>getLCP-test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;reports the correct value on hidden (reportAllChanges === false)&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 浏览器不支持就跳过这条用例</span></span><br><span class="line">    <span class="keyword">if</span> (!browserSupportsLCP) <span class="variable language_">this</span>.<span class="title function_">skip</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 /test/lcp这个网页，这是测试网页</span></span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">url</span>(<span class="string">&#x27;/test/lcp&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有图片加载完成</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">imagesPainted</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到空白页，触发上一个页面的 hide状态</span></span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">url</span>(<span class="string">&#x27;about:blank&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是beacon.log中是否有数据，参数为数据条数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">beaconCountIs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 beacon数据进行断言</span></span><br><span class="line">    <span class="title function_">assertStandardReportsAreCorrect</span>(<span class="keyword">await</span> <span class="title function_">getBeacons</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当输入<code>browser.url(&#39;/test/lcp&#39;)</code>其实访问的地址是<code>http://localhost:9090/test/lcp</code>(在wdio.config.js中配置的)。这条请求会发送给本地的HTTP服务上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/server.js</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test/:view&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    ...req.<span class="property">query</span>,</span><br><span class="line">    <span class="attr">modulePath</span>: <span class="string">`/dist/web-vitals<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        req.query.polyfill ? <span class="string">`.base`</span> : <span class="string">``</span>&#125;</span>.js`</span>,</span><br><span class="line">    <span class="attr">webVitalsPolyfill</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./dist/polyfill.js&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">send</span>(nunjucks.<span class="title function_">render</span>(<span class="string">`<span class="subst">$&#123;req.params.view&#125;</span>.njk`</span>, data));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>nunjucks</code>是一个模板引擎。data数据会插入到模板引擎内。当访问<code>/test/lcp</code>时，会将解析<code>lcp.njk</code>并将html返回给浏览器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/test/view/lcp.njk --&gt;</span></span><br><span class="line">&#123;% extends &#x27;layout.njk&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LCP Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% if not imgDelay %&#125;</span><br><span class="line">      &#123;% set imgDelay = 500 %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> &#123;% <span class="attr">if</span> <span class="attr">imgHidden</span> %&#125;<span class="attr">hidden</span>&#123;% <span class="attr">endif</span> %&#125; <span class="attr">src</span>=<span class="string">&quot;/test/img/square.png?delay=&#123;&#123; imgDelay &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text below the image<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;navigate-away&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Navigate away<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Include a tall element to ensure scrolling is possible. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100vh&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>Text below the full-height element.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;getLCP&#125; <span class="keyword">from</span> <span class="string">&#x27;&#123;&#123; modulePath &#125;&#125;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLCP</span>(<span class="function">(<span class="params">lcp</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// Log for easier manual testing.</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(lcp);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// Elements can&#x27;t be serialized, so we convert first.</span></span></span><br><span class="line"><span class="language-javascript">      lcp = &#123;</span></span><br><span class="line"><span class="language-javascript">        ...lcp,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">entries</span>: lcp.<span class="property">entries</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> (&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">element</span>: e.<span class="property">element</span>.<span class="property">nodeName</span>.<span class="title function_">toLowerCase</span>(),</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">size</span>: e.<span class="property">size</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">startTime</span>: e.<span class="property">startTime</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;)),</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 发送统计数据</span></span></span><br><span class="line"><span class="language-javascript">      navigator.<span class="title function_">sendBeacon</span>(<span class="string">`/collect`</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(lcp));</span></span><br><span class="line"><span class="language-javascript">    &#125;, self.<span class="property">__reportAllChanges</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>html中的最后一步调用了<code> navigator.sendBeacon(&quot;/collect&quot;, JSON.stringify(lcp));</code>，<code>/collect</code>这个请求也是发到本地的HTTP服务。服务端会将数据写入到<code>src/test/beacons.log</code>中。</p><h3 id="sendBeacon"><a href="#sendBeacon" class="headerlink" title="sendBeacon"></a>sendBeacon</h3><p><code>navigator.sendBeacon</code>是专门用来发送异步统计数据的API。</p><p>有一种需求：当页面跳转或关闭时，我们需要将当前页面的一些统计数据发送到服务端。往往这些数据不能提前发送。如果使用异步<code>XMLHttpRequest</code>的话，浏览器可能会忽略这个请求。如果使用同步<code>XMLHttpRequest</code>的话，会影响下个页面的加载速度。</p><p>使用<code>navigator.sendBeacon</code>，会发送一个异步请求，并且不会被浏览器忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> <span class="title function_">logData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">    navigator.<span class="title function_">sendBeacon</span>(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>判断页面关闭与否，建议使用<code>visibilitychange</code>事件</p><p>safari需要使用<code>pagehide</code>事件</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h3><p>性能观察者(PerformanceObserver)用于获取性能数据。</p><p><code>new PerformanceObserver(callback);</code> 接受一个callback作为参数</p><p><code>observer</code>方法用于注册性能条目类型，type指所要观测的性能条目类型，取值情况通过<code>PerformanceObserver.supportedEntryTypes</code>属性查看。</p><p><code>[&quot;element&quot;, &quot;event&quot;, &quot;first-input&quot;, &quot;largest-contentful-paint&quot;, &quot;layout-shift&quot;, &quot;longtask&quot;, &quot;mark&quot;, &quot;measure&quot;, &quot;navigation&quot;, &quot;paint&quot;, &quot;resource&quot;]</code></p><p>其中:</p><ul><li><code>largest-contentful-paint</code>：LCP</li><li><code>layout-shift</code>：CLS</li><li><code>first-input</code>：FID</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取lcp时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entryList</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> entryList.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LCP candidate:&#x27;</span>, entry.<span class="property">startTime</span>, entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(callback)</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;largest-contentful-paint&#x27;</span>, <span class="attr">buffered</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="LCP、FID、CLS"><a href="#LCP、FID、CLS" class="headerlink" title="LCP、FID、CLS"></a>LCP、FID、CLS</h3><p><code>web-vitals</code>中的<code>LCP</code>、<code>FID</code>和<code>CLS</code>都是通过<code>PerformanceObserver</code>来实现的。</p><p>以LCP为例：</p><p><code>getLCP</code>函数位于<code>src/getLCP.ts</code>文件中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getLCP</span> = (<span class="params">onReport: ReportHandler, reportAllChanges?: <span class="built_in">boolean</span></span>) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1 获取 第一次页面处于hidden状态的时间</span></span><br><span class="line">  <span class="keyword">const</span> firstHidden = <span class="title function_">getFirstHidden</span>();</span><br><span class="line">  <span class="keyword">let</span> metric = <span class="title function_">initMetric</span>(<span class="string">&#x27;LCP&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">report</span>: <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> bindReporter&gt;;</span><br><span class="line"></span><br><span class="line">                         </span><br><span class="line">  <span class="comment">// 2. PerformanceObserver</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">entry: PerformanceEntry</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> value = entry.<span class="property">startTime</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤掉切换pagehide后的 性能数据</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; firstHidden.<span class="property">timeStamp</span>) &#123;</span><br><span class="line">      metric.<span class="property">value</span> = value;</span><br><span class="line">      metric.<span class="property">entries</span>.<span class="title function_">push</span>(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">report</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> po = <span class="title function_">observe</span>(<span class="string">&#x27;largest-contentful-paint&#x27;</span>, entryHandler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (po) &#123;</span><br><span class="line">    report = <span class="title function_">bindReporter</span>(onReport, metric, reportAllChanges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">stopListening</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!finalMetrics.<span class="title function_">has</span>(metric)) &#123;</span><br><span class="line">        po.<span class="title function_">takeRecords</span>().<span class="title function_">map</span>(entryHandler <span class="keyword">as</span> <span class="title class_">PerformanceEntryHandler</span>);</span><br><span class="line">        po.<span class="title function_">disconnect</span>();</span><br><span class="line">        finalMetrics.<span class="title function_">add</span>(metric);</span><br><span class="line">        <span class="title function_">report</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户点击页面时，立即触发 report</span></span><br><span class="line">    [<span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;click&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params"><span class="keyword">type</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">addEventListener</span>(<span class="keyword">type</span>, stopListening, &#123;<span class="attr">once</span>: <span class="literal">true</span>, <span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onHidden</span>(stopListening, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当pageshow时，报告metric</span></span><br><span class="line">    <span class="title function_">onBFCacheRestore</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      metric = <span class="title function_">initMetric</span>(<span class="string">&#x27;LCP&#x27;</span>);</span><br><span class="line">      report = <span class="title function_">bindReporter</span>(onReport, metric, reportAllChanges);</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          metric.<span class="property">value</span> = performance.<span class="title function_">now</span>() - event.<span class="property">timeStamp</span>;</span><br><span class="line">          finalMetrics.<span class="title function_">add</span>(metric);</span><br><span class="line">          <span class="title function_">report</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><p>TTFB时间直接取<code>performance.responseStart</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web-vitals简介&quot;&gt;&lt;a href=&quot;#web-vitals简介&quot; class=&quot;headerlink&quot; title=&quot;web-vitals简介&quot;&gt;&lt;/a&gt;web-vitals简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="web-vitals" scheme="https://zxffan.github.io/tags/web-vitals/"/>
    
  </entry>
  
  <entry>
    <title>知识串联：JavaScript执行机制</title>
    <link href="https://zxffan.github.io/posts/1b8392cc.html"/>
    <id>https://zxffan.github.io/posts/1b8392cc.html</id>
    <published>2021-04-22T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.593Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将梳理JavaScript的执行机制，并且串联众多知识点：作用域、作用域链、闭包、变量提升、函数提升、<code>this</code>指向</p><h2 id="JavaScript-执行的阶段"><a href="#JavaScript-执行的阶段" class="headerlink" title="JavaScript 执行的阶段"></a>JavaScript 执行的阶段</h2><p>在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。</p><ul><li><p>语法分析阶段。 该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。</p></li><li><p>编译阶段。 该阶段会进行全局执行上下文（Execution Context）的创建，这个过程也被称为预解析阶段。</p></li><li><p>执行阶段。 将编译阶段中创建的执行上下文压入执行栈，并成为正在运行的执行上下文，代码执行结束后，将其出栈。在执行过程中，又可能会产生新的执行上下文（比如调用了函数）。再将新的执行上下文入栈，执行完出栈</p></li></ul><h2 id="三种执行上下文"><a href="#三种执行上下文" class="headerlink" title="三种执行上下文"></a>三种执行上下文</h2><p>执行上下文是对执行环境的抽象，它代表JavaScript执行时当前的执行环境，用于。JavaScript中一共有三种执行上下文</p><ul><li>全局执行上下文：有且仅有一个</li><li>函数执行上下文</li><li><code>eval</code>执行上下文：不讨论</li></ul><p>如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;zxfan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure><p>编译时，首先创建一个全局执行上下文<code>GlobalContext</code>，并将其放入执行栈</p><p>执行时，执行栈栈顶的执行上下文为当前正在执行的执行上下文，当执行到<code>sayName</code>函数时，又会创建一个函数执行上下文<code>FunctionContext</code>，并将其入栈。当函数执行上下文执行完毕，出栈。全局上下文也执行完毕，出栈。</p><blockquote><p>全局执行上下文是编译时被创建的</p><p>函数执行上下文是执行时被创建的</p></blockquote><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈是用来存放执行上下文的。</p><p>以函数为例，函数执行的时候创建函数执行上下文，并将其入栈，当函数执行完成后再出栈。全局执行上下文第一个入栈最后一个出栈。</p><h2 id="执行上下文做了什么？"><a href="#执行上下文做了什么？" class="headerlink" title="执行上下文做了什么？"></a>执行上下文做了什么？</h2><p>执行上下文被创建时，做了三件事：</p><ul><li>确定<code>this</code>的指向</li><li>创建环境记录<ul><li>创建词法环境(LexicalEnvironment)</li><li>创建变量环境(VariableEnvironment)</li></ul></li></ul><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>this的取值取决于具体的场景：</p><ul><li>全局执行上下文中：this取全局对象（浏览器是window对象，nodejs是global对象）</li><li>函数执行上下文中：<ul><li>构造函数中：指向创建的实例对象</li><li>对象方法：this指向这个对象</li><li>箭头函数：外层执行上下文的this</li><li><code>call</code> <code>apply</code> <code>bind</code>：可以指定this</li><li>其它情况：this为undefined（严格模式下）</li></ul></li></ul><h3 id="环境记录-Environment-Record"><a href="#环境记录-Environment-Record" class="headerlink" title="环境记录(Environment Record)"></a>环境记录(Environment Record)</h3><p>基于JavaScript这种嵌套的代码结构，环境记录用来记录特定的<strong>标识符</strong>和代码中所定义的<strong>变量和函数</strong>之间的关系。</p><p>换句话说，环境记录就是记录一堆标识符，这些标识符指向具体代码中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zxfan&quot;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">function <span class="title function_">sayName</span><span class="params">()</span> &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其环境记录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment Record <span class="punctuation">&#123;</span></span><br><span class="line">name<span class="punctuation">:</span> &lt;uninitialized&gt; <span class="comment">// 代码执行完后 name: &lt;&quot;zxfan&quot;&gt;</span></span><br><span class="line">  age<span class="punctuation">:</span> &lt;<span class="number">18</span>&gt; <span class="comment">// var 具有变量提升，所以这里不是uninitialized</span></span><br><span class="line">sayName<span class="punctuation">:</span> &lt;function&gt; <span class="comment">// function有函数提升，所以这里不是uninitialized</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>环境记录分类三种类型（声明环境记录又分为两种）：</p><ul><li>声明环境记录： 包含<code>var</code> <code>let</code> <code>const</code> <code>class</code> <code>function</code>  <code>import</code>声明的变量的标识符。<ul><li>函数环境记录： <code>function</code></li><li>模块环境记录：<code>import</code></li></ul></li><li>对象环境记录：为对象创建一个环境记录，它有一个**关联的绑定对象[[BindingObject]]**。比如全局执行上下文会创建一个对象环境记录，其关联绑定的对象是全局对象（window或global）</li><li>全局环境记录：最外层环境记录，包含声明环境记录和对象环境记录</li></ul><p><strong>词法环境和变量环境本质上都是环境记录</strong>，这么做是为了单独区分<code>var</code></p><h4 id="词法环境（作用域）"><a href="#词法环境（作用域）" class="headerlink" title="词法环境（作用域）"></a>词法环境（作用域）</h4><p>词法环境可以理解为<strong>作用域</strong>，从词法环境的角度能更好地理解作用域。词法环境有两个成员：</p><ul><li>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</li><li>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</li></ul><h5 id="环境记录"><a href="#环境记录" class="headerlink" title="环境记录"></a>环境记录</h5><p>词法环境的环境记录，会保存<strong>函数声明</strong>和<strong>变量声明</strong>(<code>let</code>和<code>const</code>声明的变量)，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = <span class="string">&quot;Donald&quot;</span></span><br><span class="line">  <span class="keyword">const</span> lastName = <span class="string">&quot;Trump&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(firstName, lastName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayFullName</span>()</span><br></pre></td></tr></table></figure><p><code>sayFullNmae</code>的词法环境</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnciroment <span class="punctuation">&#123;</span></span><br><span class="line">Enviroment Record <span class="punctuation">&#123;</span></span><br><span class="line">firstName<span class="punctuation">:</span> &lt;uninitialize&gt;</span><br><span class="line">lastName<span class="punctuation">:</span> &lt;uninitialize&gt;</span><br><span class="line">arguments<span class="punctuation">:</span> &lt;<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>&gt;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">outer<span class="punctuation">:</span> &lt;Global or outer function environment reference&gt;  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：<code>let</code>和<code>const</code>定义的变量初始都是<code>uninitialize</code>。当代码执行后才会赋值。</p><h5 id="外部词法环境引用（作用域链）"><a href="#外部词法环境引用（作用域链）" class="headerlink" title="外部词法环境引用（作用域链）"></a>外部词法环境引用（作用域链）</h5><p>任何一个词法环境（全局词法环境除外）都有一个指向外层词法环境的引用。这构成了词法环境链即<strong>作用域链</strong>。当访问一个变量时，先会在当前词法环境中寻找，找不到就去外部词法环境中寻找。就这样，一直找到全局词法环境。</p><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境和词法环境的结构一致，区别是其环境记录所记录的数据不同。</p><p>语法环境的环境记录，是记录<code>var</code>声明。</p><blockquote><p>环境记录 词法环境 作用域 其实都是一个概念，这么区分是为了针对不同场景方便理解。</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="解释作用域与作用域链"><a href="#解释作用域与作用域链" class="headerlink" title="解释作用域与作用域链"></a>解释作用域与作用域链</h3><p>JS的作用域时词法作用域，有词法结构决定。js代码编译时创建全局执行上下文，执行上下文又会创建当前环境的环境记录（分为词法环境和变量环境）。当执行js代码时（比如调用一个函数），又会创建函数执行上下文。随之函数环境的环境就又会创建。</p><p>每个环境记录都有个outer引用，指向外层环境记录。外层再指向外层，一直到最外层。这便构成了作用域链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>解释闭包就是解释<strong>作用域</strong>和<strong>垃圾回收机制</strong></p><p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p><p>正常情况下，代码执行完毕，其相应的执行上下文出栈，相应的内存空间会被回收。然而，闭包情况下，内层词法环境（作用域）可以访问到，所以外层词法环境不会被回收，仍然可以访问到，但仅限在内层词法环境访问。</p><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><p>环境记录创建时，会记录当前环境下所有变量，遇到：</p><ul><li><p>var变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</p></li><li><p>函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</p></li></ul><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this指向是在执行上下文创建时才确定的，具体指向谁取决于具体场景。上文已讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章将梳理JavaScript的执行机制，并且串联众多知识点：作用域、作用域链、闭包、变量提升、函数提升、&lt;code&gt;this&lt;/code&gt;指向&lt;/p&gt;
&lt;h2 id=&quot;JavaScript-执行的阶段&quot;&gt;&lt;a href=&quot;#JavaScript-执行的阶段&quot; clas</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击与防御</title>
    <link href="https://zxffan.github.io/posts/df6ed6ff.html"/>
    <id>https://zxffan.github.io/posts/df6ed6ff.html</id>
    <published>2021-04-15T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.598Z</updated>
    
    <content type="html"><![CDATA[<p><code>xss(cross-site script)</code>指<strong>网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的</strong></p><p>攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中执行被注入的恶意代码，从而窃取用户身份，执行一些敏感操作</p><h2 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h2><p>XSS攻击可以分成三种类型：</p><ul><li><p>反射型XSS</p></li><li><p>存储型XSS</p></li><li><p>DOM型XSS</p></li></ul><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型指的是<strong>将攻击代码存放在URL参数中</strong>，例如<code>http://localhost/home?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>。</p><p>如果服务端直接去url中的name参数，并当作html返回给客户端。攻击代码就会执行。</p><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型是指<strong>将恶意代码存储到服务器上</strong>，只要诱使受害者访问被插入恶意代码的页面即可触发。存储型 XSS 经常出现在一些可以发表评论的地方，如帖子、博客</p><p>当用户在评论中输入一段攻击代码，网站又没有过滤。这段代码会存储到数据库中。当其它用户访问评论时，这段攻击代码被当作html内容输出就会引发攻击代码的执行</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p><strong>前两种都是服务端的XSS，DOM型是客户端的XSS</strong></p><p>JavaScript 能够操作DOM。通过JavaScript控制获取<strong>源数据（内含攻击代码）</strong>，又未进行处理。直接<strong>当作HTML输出（innerHTML）或脚本执行</strong></p><p>就会发生DOM型XSS攻击</p><p>常见的源数据有：<code>document</code> <code>location</code> <code>localStorage</code> <code>sessionStorage</code>等</p><p>常见的触发攻击的点：<code>document.write</code> <code>eval</code> <code>innerHTML</code> <code>a的href属性</code>等</p><h2 id="XSS常见的攻击方式"><a href="#XSS常见的攻击方式" class="headerlink" title="XSS常见的攻击方式"></a>XSS常见的攻击方式</h2><h3 id="窃取cookie"><a href="#窃取cookie" class="headerlink" title="窃取cookie"></a>窃取cookie</h3><p>许多网站都使用<code>cookie</code>来存放用户登陆信息。</p><p>攻击者利用<code>xss</code>漏洞来注入脚本。<code>document.cookie</code>就可以获取到cookie。然后再将获取到的cookie上报。之后就可以本地修改 Cookie 来登录受害者的账号</p><h3 id="蠕虫攻击"><a href="#蠕虫攻击" class="headerlink" title="蠕虫攻击"></a>蠕虫攻击</h3><p>以微博XSS蠕虫攻击为例：</p><ul><li><p>利用 XSS 漏洞插入恶意 JS 代码；</p></li><li><p>利用 XMLHttpRequest 发送请求去发表微博、关注用户、获取关注者列表并向其发送私信；</p></li><li><p>微博消息和私信都包含有恶意攻击链接，等于实现了攻击代码的自我复制和传播。</p></li></ul><h3 id="获取用户键盘记录"><a href="#获取用户键盘记录" class="headerlink" title="获取用户键盘记录"></a>获取用户键盘记录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  keys += <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">keyCode</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取剪贴板内容"><a href="#获取剪贴板内容" class="headerlink" title="获取剪贴板内容"></a>获取剪贴板内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;paste&#x27;</span>, <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">  clipdata = evt.<span class="property">clipboardData</span> || <span class="variable language_">window</span>.<span class="property">clipboardData</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(clipdata.<span class="title function_">getData</span>(<span class="string">&#x27;text/plain&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="钓鱼欺骗用户输入账号、密码"><a href="#钓鱼欺骗用户输入账号、密码" class="headerlink" title="钓鱼欺骗用户输入账号、密码"></a>钓鱼欺骗用户输入账号、密码</h3><p>弹个弹窗，让用户输入账号密码</p><h2 id="XSS漏洞挖掘"><a href="#XSS漏洞挖掘" class="headerlink" title="XSS漏洞挖掘"></a>XSS漏洞挖掘</h2><h4 id="收集用例"><a href="#收集用例" class="headerlink" title="收集用例"></a>收集用例</h4><p>人工测试的主要思路就是在一切可输入数据的地方输入“XSS payload”（测试用例），这些地方包括所有的 GET、POST、Cookie、HTTP 头。提交数据之后，看网站的输出是否解析了前面输入的 XSS payload。</p><p>我常用的 XSS payload 有以下几个。搜索“XSS cheat sheet”，也可以找到很多这种测试用例。</p><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet">Cross-site scripting (XSS) cheat sheet</a></p><p><a href="https://owasp.org/www-community/xss-filter-evasion-cheatsheet">XSS Filter Evasion Cheat Sheet</a></p><p><a href="http://html5sec.org/">HTML5 Security Cheatsheet</a></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这一步可以手动测试也可以采用自动测试工具。</p><p>手动：可以先一次性批量输入测试，如果无效，再输入一些特殊字符看过滤情况，根据返回数据作相应的调整测试。</p><p>自动：<a href="https://github.com/s0md3v/XSStrike">XSStrike</a>，它内置了很多测试用例，也可以添加自定义测试用例</p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="做好检查"><a href="#做好检查" class="headerlink" title="做好检查"></a>做好检查</h3><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>检查攻击者所有可能的输入的地方</p><ul><li><code>URL</code>参数</li><li>（富）文本框</li><li>接口返回的数据</li></ul><blockquote><p>服务端也需要进行检查，前端是可以绕过去的</p></blockquote><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>从前端角度来看，有两个地方可能导致恶意代码执行——<code>HTML</code>和<code>JavaScript</code></p><ul><li><p>HTML：<code>innerHTML</code> <code>outerHTML</code> <code>document.write()</code> <code>v-html</code> <code>danderousSetInnerHTML</code></p><p>将原数据当作HTML输出，极容易导致XSS攻击。尽量避免这么做，使用<code>textContent</code>来代替。如果必须输出（如评论内容），需要进行<strong>转义</strong>。通常使用<strong>白名单</strong>的方式进行转义。</p><blockquote><p><a href="https://www.npmjs.com/package/xss">xss</a>是npm上的一个不错的HTML转义库</p></blockquote></li><li><p>JavaScript：</p><ul><li>内联事件监听器：<code>location</code> <code>onclick</code> <code>onerror</code> <code>onload</code> <code>onmousemove</code>等等等</li><li>a标签的href属性使用伪协议：<code>&lt;a href=&quot;javascript:alert(&#39;attack&#39;)&quot; /&gt;</code></li><li><code>eval</code> <code>setTimeout</code> <code>setInterval</code>都能够把字符串当作js执行</li></ul><p>这些api的不恰当使用会导致XSS攻击，所以使用时要格外注意。好在它们大多都有可替代方案。</p></li></ul><h3 id="HttpOnly禁止cookie访问"><a href="#HttpOnly禁止cookie访问" class="headerlink" title="HttpOnly禁止cookie访问"></a>HttpOnly禁止cookie访问</h3><p>如果给某个 cookie 设置了 <code>HttpOnly</code> 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: Name=Value; expires=Wednesday, 01-May-2014 12:45:10 GMT; HttpOnly</span><br></pre></td></tr></table></figure><blockquote><p>cookie由服务端创建返回给浏览器的（响应头：<code>Set-Cookie</code>）。之后的请求会自动携带cookie。默认情况下，它随着seesion的结束而结束。</p><p>能不使用cookie就别使用了</p></blockquote><h3 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP 内容安全策略"></a>CSP 内容安全策略</h3><p>内容安全策略（Content Security Policy，CSP）也是减少 XSS 攻击的一种方式 ，是浏览器提供一种防御机制。它采用的是白名单机制，告诉浏览器可以加载和执行哪些外部资源，这样就能防止被一些第三方恶意脚本注入执行。</p><p>开启 CSP 有两种方式：</p><ol><li><p>通过 HTTP 头信息的 Content-Security-Policy 的字段：(在返回html文件的请求的响应头上加)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;;style-src cdn.example.org third-party.org; child-src https:（2）通过网页的&lt;meta&gt;标签设置：</span><br></pre></td></tr></table></figure></li><li><p>通过网页的<code>&lt;meta&gt;</code>标签设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>如何指定csp：<strong>指令 策略</strong></p><p>指令字段含义：</p><table><thead><tr><th>指令</th><th>策略示例</th><th>含义</th></tr></thead><tbody><tr><td><code>default-src</code></td><td><code>&#39;self&#39; www.aaa.com</code></td><td>默认资源加载策略，没有指定策略的指令使用本策略</td></tr><tr><td><code>script-src</code></td><td><code>&#39;selft&#39; js.a.com</code></td><td>针对js文件的策略</td></tr><tr><td><code>style-src</code></td><td><code>&#39;selft&#39; css.a.com</code></td><td>针对css文件的策略</td></tr><tr><td><code>img-src</code></td><td><code>&#39;selft&#39; img.a.com</code></td><td>针对img图片资源的策略</td></tr><tr><td><code>connect-src</code></td><td><code>&#39;selft&#39;</code></td><td>针对ajax、websocket的策略，不允许会返回400</td></tr><tr><td><code>font-src</code></td><td><code>font.a.com</code></td><td>针对字体的加载策略</td></tr><tr><td><code>media-src</code></td><td><code>media.a.com</code></td><td>针对video和audio引入资源的策略</td></tr><tr><td><code>frame-src</code></td><td><code>&#39;self&#39;</code></td><td>针对frame的加载策略</td></tr><tr><td><code>sandbox</code></td><td><code>allow-forms</code></td><td>对请求资源启用<code>sandbox</code></td></tr><tr><td><code>report-uri</code></td><td><code>/report-uri</code></td><td>告知浏览器，当请求资源不被策略允许时，往那个接口提交信息</td></tr></tbody></table><p>指令值字段含义：</p><ul><li><code>none</code> 表示不执行任何匹配。</li><li><code>self</code>表示与当前来源（而不是其子域）匹配。</li><li><code>unsafe-inline</code>表示允许使用内联 JavaScript 和 CSS。</li><li><code>unsafe-eval</code> 表示允许使用类似 eval 的 text-to-JavaScript 机制。</li><li><code>www.aasd.com</code>允许加载指定域名的资源</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;xss(cross-site script)&lt;/code&gt;指&lt;strong&gt;网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中</summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="FrontEnd" scheme="https://zxffan.github.io/tags/FrontEnd/"/>
    
    <category term="安全" scheme="https://zxffan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序问题梳理</title>
    <link href="https://zxffan.github.io/posts/88f2a5b3.html"/>
    <id>https://zxffan.github.io/posts/88f2a5b3.html</id>
    <published>2021-04-14T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="数组的归并排序"><a href="#数组的归并排序" class="headerlink" title="数组的归并排序"></a>数组的归并排序</h3><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>归并排序类似二叉树的后序遍历，思想也一致：利用子树的信息推算出整棵树的信息</p><p>记忆：</p><ol><li>将list划分成两部分，</li><li>后序遍历</li><li>合并两个有序list</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[], low = <span class="number">0</span>, high = nums.length - <span class="number">1</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="comment">// 1. 划分</span></span><br><span class="line">    <span class="keyword">const</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.后续遍历</span></span><br><span class="line">    <span class="title function_">sortArray</span>(nums, low, mid);</span><br><span class="line">    <span class="title function_">sortArray</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 合并两个有序list</span></span><br><span class="line">    <span class="title function_">merge</span>(nums, low, mid, high);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="comment">// 数组A： nums[low ... mid]</span></span><br><span class="line"><span class="comment">// 数组B：nums[mid+1 ... high]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">nums: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, mid: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">store</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个数组的起始索引</span></span><br><span class="line">  <span class="keyword">let</span> i = low;</span><br><span class="line">  <span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[j]) store.<span class="title function_">push</span>(nums[i++]);</span><br><span class="line">    <span class="keyword">else</span> store.<span class="title function_">push</span>(nums[j++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) store.<span class="title function_">push</span>(nums[i++]);</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= high) store.<span class="title function_">push</span>(nums[j++]);</span><br><span class="line"></span><br><span class="line">  store.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> (nums[low++] = num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(nlgn)，空间复杂度 O(n)</p><h3 id="链表的归并排序"><a href="#链表的归并排序" class="headerlink" title="链表的归并排序"></a>链表的归并排序</h3><p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></p><p>思路都一样，同样的三步</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.划分</span></span><br><span class="line">  <span class="keyword">const</span> [back, front] = <span class="title function_">divide</span>(head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.后续遍历</span></span><br><span class="line">  <span class="keyword">const</span> left = <span class="title function_">sortList</span>(back);</span><br><span class="line">  <span class="keyword">const</span> right = <span class="title function_">sortList</span>(front);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.合并两个有序链表</span></span><br><span class="line">  dummy.<span class="property">next</span> = <span class="title function_">merge</span>(left, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表划分成两部分</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">head: ListNode</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> back = head;</span><br><span class="line">  <span class="keyword">let</span> front = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (front.<span class="property">next</span>) &#123;</span><br><span class="line">    front = front.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (front.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    front = front.<span class="property">next</span>;</span><br><span class="line">    back = back;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [head, back.<span class="property">next</span>!];</span><br><span class="line">  back.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序列表 l1 l2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">l1: ListNode | <span class="literal">null</span>, l2: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">  <span class="keyword">let</span> tail = dummy;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">      tail.<span class="property">next</span> = l1;</span><br><span class="line">      l1 = l1.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tail.<span class="property">next</span> = l2;</span><br><span class="line">      l2 = l2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = tail.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l1) tail.<span class="property">next</span> = l1;</span><br><span class="line">  <span class="keyword">if</span> (l2) tail.<span class="property">next</span> = l2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><p>这道题也是利用归并排序中的<strong>分治思想</strong>。现将数组不断划分，然后合并两个有序数组<code>a[low...mid]</code>和<code>a[mid+1...high]</code>，循环比较<code>a[i]</code>和<code>a[j]</code>的大小</p><ul><li>如果<code>a[j]</code>小，即<code>a[i...mid]</code>所有元素都比<code>a[j]</code>大，也就是说它们构成了逆序对。逆序对的数量加上<code>mid-i+1</code></li><li>如果<code>a[i]</code>小，无需处理</li></ul><h3 id="右侧较小元素个数"><a href="#右侧较小元素个数" class="headerlink" title="右侧较小元素个数"></a>右侧较小元素个数</h3><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[], low = <span class="number">0</span>, high = nums.length - <span class="number">1</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">partition</span>(nums, low, high);</span><br><span class="line">    <span class="title function_">sortArray</span>(nums, low, index - <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">sortArray</span>(nums, index + <span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = nums[low];</span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= target) high--;</span><br><span class="line">    nums[low] = nums[high];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= target) low++;</span><br><span class="line">    nums[high] = nums[low];</span><br><span class="line">  &#125;</span><br><span class="line">  nums[low] = target;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h3 id=&quot;数组的归并排序&quot;&gt;&lt;a href=&quot;#数组的归并排序&quot; class=&quot;headerlink&quot; title=&quot;数组的</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>队列问题梳理</title>
    <link href="https://zxffan.github.io/posts/631e9859.html"/>
    <id>https://zxffan.github.io/posts/631e9859.html</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS 广度优先遍历"></a>BFS 广度优先遍历</h2><p>BFS、广度优先、层序遍历都是一回事。需要通过队列来实现</p><h3 id="队列实现BFS"><a href="#队列实现BFS" class="headerlink" title="队列实现BFS"></a>队列实现BFS</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     left: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     right: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *         this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>[] = [root]</span><br><span class="line">  <span class="keyword">const</span> ans = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> ans</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">    ans.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="按层次输出层序遍历"><a href="#按层次输出层序遍历" class="headerlink" title="按层次输出层序遍历"></a>按层次输出层序遍历</h3><p>在层序遍历的过程中还要记住当前处在拿一层</p><ul><li>用一个last指针指向每一层最后一个节点</li><li>或者，前序遍历。逐个给每一层添加元素。前序遍历是先遍历第一个第一个元素，然后第二层第一个元素….</li></ul><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>往往，考题不会只靠队列这一个点。层序遍历只是解决问题的一个手段</p><h3 id="填充右侧节点"><a href="#填充右侧节点" class="headerlink" title="填充右侧节点"></a>填充右侧节点</h3><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><p>考点：层序遍历+last指针记住层次</p><p>层次遍历到当前节点时：</p><ul><li>当前节点是last：不修改next指针</li><li>不是last：将当前节点的next指向队列中第一个元素</li></ul><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a></p><p>循环队列有两种实现方式</p><h4 id="fornt-rear-used"><a href="#fornt-rear-used" class="headerlink" title="fornt+rear+used"></a>fornt+rear+used</h4><p><img src="/../../images/algorithm/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%971.png" alt="循环队列"></p><p>front和rear分别指向队头和队尾，used记录队列的元素个数，当：</p><ul><li>队列为空：front &#x3D; rear且used&#x3D;0</li><li>队列满了：front&#x3D;rear且used&#x3D;队列长度</li><li>其它情况：front !&#x3D; rear，used&#x3D;队列元素个数</li></ul><h4 id="浪费一个空间"><a href="#浪费一个空间" class="headerlink" title="浪费一个空间"></a>浪费一个空间</h4><p><img src="/../../images/algorithm/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%972.png" alt="循环队列2"></p><p>front和rear分别指向队头和队尾，当：</p><ul><li>队列为空：front &#x3D; rear</li><li>队列满了：(rear + 1) % capacity &#x3D;&#x3D; front</li><li>其它情况：front !&#x3D; rear</li></ul><h3 id="🌟在js中实现循环队列"><a href="#🌟在js中实现循环队列" class="headerlink" title="🌟在js中实现循环队列"></a>🌟在js中实现循环队列</h3><p>无需指针，直接调用数组对象的<code>push</code>和<code>shift</code>方法模拟队列。</p><p>循环队列的出现是因为其它语言的数组是定长的，在声明时就要指定长度，所以需要充分利用空间。而JavaScript中的数组，无需声明是指定长度。所以并不需要循环队列这种数据结构。</p><p>理论上<code>shift</code>删除队列首元素，会导致后面所有元素向前移动一位。但是在<code>v8</code>的优化下，这种方式比<code>front</code>+<code>rear</code>两个指针要快</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">queue</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">k: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFull</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deQueue</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Front</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Rear</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isFull</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列：</p><ul><li>基于双端队列：两端都可以入队和出队</li><li>队列元素满足<strong>单调递增</strong>或者<strong>单调递减</strong></li></ul><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BFS-广度优先遍历&quot;&gt;&lt;a href=&quot;#BFS-广度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;BFS 广度优先遍历&quot;&gt;&lt;/a&gt;BFS 广度优先遍历&lt;/h2&gt;&lt;p&gt;BFS、广度优先、层序遍历都是一回事。需要通过队列来实现&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>vue3-任务调度</title>
    <link href="https://zxffan.github.io/posts/d2a05aba.html"/>
    <id>https://zxffan.github.io/posts/d2a05aba.html</id>
    <published>2021-04-03T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.599Z</updated>
    
    <content type="html"><![CDATA[<p>在vue3中，修改一个响应式对象，像是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;my-name&quot;</span>&gt;</span>name: &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;zxfan&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">name.<span class="property">value</span> += <span class="string">&#x27; yes!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当执行<code>name.value += &#39; yes!&#39;</code>，<code>vue3</code>并不会立即触发当前组件的更新。而是将更新任务放到任务队列中。这一点与vue2一致。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>调度相关的源码位于<code>runtime-core/src/schduler.ts</code>中</p><p>在任务调度过程中，任务会被放入三类任务队列中：</p><ul><li><p>preFlushCbs：要在执行queue之前执行的队列</p></li><li><p>queue：任务队列</p></li><li><p>postFlush：要在执行queue之后执行的队列</p></li></ul><p>每一次flush的过程（或者说一个<code>Tick</code>），都是按照<strong>清空preFlushCbs队列-&gt;清空queue队列-&gt;清空postFlush队列</strong>的顺序</p><blockquote><p>flush 指刷新任务队列，或者说 执行完任务队列中所有的任务</p></blockquote><h2 id="入队queue的时机"><a href="#入队queue的时机" class="headerlink" title="入队queue的时机"></a>入队queue的时机</h2><p><code>queue</code>存放的都是组件渲染任务</p><h3 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h3><p>先提一下vue中的响应式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;effect, ref&#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>) <span class="comment">// 会输出两次，分别是 20 和 21</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">age.<span class="property">value</span> = <span class="number">21</span></span><br></pre></td></tr></table></figure><p><code>effect</code>的回调函数会被响应式得重写触发执行。</p><p>那么回到本文最开始的例子中，当执行<code>name.value += &#39; yes!&#39;</code>。响应式数据变化了，触发（<code>trigger</code>）其关联到的<code>effect</code>重新执行。那么需要重新执行的<code>effect</code>在哪里声明的呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtie-core/src/renderer.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">setupRenderEffect</span>: <span class="title class_">SetupRenderEffectFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">  instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 省略。。。创建或更新 VNode</span></span><br><span class="line">  &#125;, __DEV__ ? <span class="title function_">createDevEffectOptions</span>(instance) : prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setupRenderEffect</code>给组件套上了个<code>effect</code>。这个函数是组件实例创建的时候调用的。</p><p>当修改组件内的响应式数据时，会触发该<code>effect</code>重新执行。</p><p>当然不会直接就执行了，注意到了吗，effect还有第二个参数。第二个参数的类型如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ReactiveEffectOptions</span> &#123;</span><br><span class="line">  lazy?: <span class="built_in">boolean</span> <span class="comment">// 该effect是否</span></span><br><span class="line">  scheduler?: <span class="function">(<span class="params">job: ReactiveEffect</span>) =&gt;</span> <span class="built_in">void</span> <span class="comment">// 调度</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它先不关注，我们只看<code>scheduler</code>属性。</p><p>如果有这个属性，就不会直接执行<code>effect</code>，而是调用这个<code>scheduler</code>函数，并且将<code>effect</code>作为参数传给它</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect: ReactiveEffect</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有scheduler 调用 scheduler</span></span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接执行 effect</span></span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  effects.<span class="title function_">forEach</span>(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在给组件实例套上<code>effect</code>的时候，传给<code>effect</code>的第二个参数是什么呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtie-core/src/renderer.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodEffectOptions = &#123;</span><br><span class="line">  <span class="attr">scheduler</span>: queueJob,</span><br><span class="line">  <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">  <span class="attr">allowRecurse</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createDevEffectOptions</span>(<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ReactiveEffectOptions</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">scheduler</span>: queueJob,</span><br><span class="line">    <span class="attr">allowRecurse</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">onTrack</span>: instance.<span class="property">rtc</span> ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtc</span>!, e) : <span class="built_in">void</span> <span class="number">0</span>,</span><br><span class="line">    <span class="attr">onTrigger</span>: instance.<span class="property">rtg</span> ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtg</span>!, e) : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</code>根据不同的环境传递的参数有一些差异性。但是我们只关注scheduler，<code>scheduler</code>的值都是<code>queueJob</code>这个函数</p><p><code>queueJob</code>的作用就是将<code>effect</code>放入<code>queue</code>任务队列。</p><p>稍后在讨论<code>queueJob</code>具体都做了些什么，先总结一下组件更新的调度流程</p><ol><li><p>组件实例创建时，套上了effect方法</p></li><li><p>修改响应式数据，触发effect重新执行（先调用trigger函数）</p></li><li><p>effect的第二个参数中有<code>scheduler</code>属性，所以不会直接执行effect方法，而是将调用<code>scheduler</code>方法即<code>queueJob</code></p></li><li><p>将组件更新effect放入<code>queue</code>队列中</p></li></ol><h3 id="调用forceUpdate"><a href="#调用forceUpdate" class="headerlink" title="调用forceUpdate"></a>调用forceUpdate</h3><p>在<code>vue2</code>中可以使用<code>this.$forceUpdate</code>强制组件重新渲染。这一API在vue3 Options API中保留了下来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/componentPublicInstance.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">publicPropertiesMap</span>: <span class="title class_">PublicPropertiesMap</span> = <span class="title function_">extend</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>), &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">$forceUpdate</span>: <span class="function"><span class="params">i</span> =&gt;</span> <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(i.<span class="property">update</span>),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">PublicPropertiesMap</span>)</span><br></pre></td></tr></table></figure><p>可以观察到，<code>forceUpdate</code>就是直接调用<code>queueJob</code>，并将<code>effect</code>(i.update就是effect)传入。</p><h3 id="hmr"><a href="#hmr" class="headerlink" title="hmr"></a>hmr</h3><p>开发环境下，热更新也会触发组件重新渲染。也是调用<code>queueJob</code>将更新任务加入任务队列</p><h2 id="入队preFlushCbs和postFlushCbs的时机"><a href="#入队preFlushCbs和postFlushCbs的时机" class="headerlink" title="入队preFlushCbs和postFlushCbs的时机"></a>入队preFlushCbs和postFlushCbs的时机</h2><p><code>preFlushCbs</code>存放的是组件渲染前需要完成的任务</p><p><code>postFlushCbs</code>存放的是组件渲染完成后要完成的任务</p><h3 id="watchEffect和watch"><a href="#watchEffect和watch" class="headerlink" title="watchEffect和watch"></a>watchEffect和watch</h3><p>以<code>watchEffect</code>为例，看一下它的类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: (onInvalidate: InvalidateCbRegistrator) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  options?: WatchEffectOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">StopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WatchEffectOptions</span> &#123;</span><br><span class="line">  flush?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span> <span class="comment">// 默认：&#x27;pre&#x27;</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>watchEffect</code>的第二个参数中有个<code>flush</code>属性，有三种取值</p><ul><li><code>pre</code>（默认）：在组件渲染前异步调用，会将任务放入<code>preFlushCbs</code>队列中</li><li><code>post</code>：在组件渲染后异步调用，会将任务放入<code>postFlushCbs</code>队列中</li><li><code>sync</code>：同步调用</li></ul><p>分析源码，来看一下具体放入队列的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: WatchEffect,</span></span><br><span class="line"><span class="params">  options?: WatchOptionsBase</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="comment">// 调用doWatch方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params"></span></span><br><span class="line"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span><br><span class="line"><span class="params">  instance = currentInstance</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> <span class="attr">job</span>: <span class="title class_">SchedulerJob</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 会执行传入的回调 cb</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值scheduler</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">scheduler</span>: <span class="title class_">ReactiveEffectOptions</span>[<span class="string">&#x27;scheduler&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">    scheduler = job</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">        <span class="title function_">queuePreFlushCb</span>(job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次执行，组件未渲染的话，同步执行</span></span><br><span class="line">        <span class="title function_">job</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect</span></span><br><span class="line">  <span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>, <span class="comment">// true的话， effect第一次不会自动执行，而是直接返回effect</span></span><br><span class="line">    onTrack,</span><br><span class="line">    onTrigger,</span><br><span class="line">    scheduler</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li><p>响应式都是通过<code>effect</code>来实现的</p></li><li><p>先赋值<code>sheduler</code>，有三种情况</p><ul><li><code>flush: sync</code>：直接赋值<code>job</code>，也就是直接触发effect执行</li><li><code>flush: post</code>：赋值一个函数，函数会执行<code>queuePostRenderEffect</code>，即将<code>job</code>放入<code>postFlushCbs</code>队列</li><li><code>flush: pre</code>：赋值一个函数，函数会执行<code>queuePreRenderEffect</code>，即将<code>job</code>放入<code>preFlushCbs</code>队列</li></ul></li><li><p>创建<code>effect</code>，以实现响应式 并将<code>scheduler</code>传入。当响应式数据发生变化，就会调用<code>scheduler</code>函数</p></li></ol><p>除此之外，在Vnode创建、更新和销毁的过程中，许多环节需要在组件更新完之后再去执行相应操作。vue调用了<code>queuePostFlushCb</code>。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>现在来具体看一下这些<strong>任务</strong>进入任务队列中都做了什么：</p><h3 id="queueJob"><a href="#queueJob" class="headerlink" title="queueJob"></a>queueJob</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断队列中是否已有该job，没有才会添加到任务队列中</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!queue.<span class="property">length</span> ||</span><br><span class="line">      !queue.<span class="title function_">includes</span>(</span><br><span class="line">        job,</span><br><span class="line">        isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex</span><br><span class="line">      )) &amp;&amp;</span><br><span class="line">    job !== currentPreFlushParentJob</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 找的任务在任务队列中合适的位置</span></span><br><span class="line">    <span class="keyword">const</span> pos = <span class="title function_">findInsertionIndex</span>(job)</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">splice</span>(pos, <span class="number">0</span>, job)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空任务队列</span></span><br><span class="line">    <span class="title function_">queueFlush</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行重复判断。<strong>这是确保任务队列中不会出现多个相同组件的effect，防止组件重复渲染</strong>。</p><p>最终调用<code>queueFlush</code>来执行清空任务队列（执行完所有任务）</p><h3 id="queuePreFlushCb"><a href="#queuePreFlushCb" class="headerlink" title="queuePreFlushCb"></a>queuePreFlushCb</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueCb</span>(<span class="params"></span></span><br><span class="line"><span class="params">  cb: SchedulerCbs,</span></span><br><span class="line"><span class="params">  activeQueue: SchedulerCb[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  pendingQueue: SchedulerCb[],</span></span><br><span class="line"><span class="params">  index: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isArray</span>(cb)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !activeQueue ||</span><br><span class="line">      !activeQueue.<span class="title function_">includes</span>(</span><br><span class="line">        cb,</span><br><span class="line">        (cb <span class="keyword">as</span> <span class="title class_">SchedulerJob</span>).<span class="property">allowRecurse</span> ? index + <span class="number">1</span> : index</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      pendingQueue.<span class="title function_">push</span>(cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pendingQueue.<span class="title function_">push</span>(...cb)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 清空任务队列</span></span><br><span class="line">  <span class="title function_">queueFlush</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePreFlushCb</span>(<span class="params">cb: SchedulerCb</span>) &#123;</span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePostFlushCb</span>(<span class="params">cb: SchedulerCbs</span>) &#123;</span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queuePreFlushCb</code>和<code>queuePostFlushCb</code>都会再去调用<code>queueCb</code>函数，这个函数做两件事</p><ol><li>将任务放入响应的任务队列（当然 先判断重复）</li><li>执行<code>queueFlush</code>，来清空任务队列</li></ol><h3 id="queueFlush"><a href="#queueFlush" class="headerlink" title="queueFlush"></a>queueFlush</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">resolvedPromise</span>: <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 清空preFlushCb队列</span></span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>(seen)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 清空queue队列</span></span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job) &#123;</span><br><span class="line">        <span class="comment">// 执行job，也就是前面传入的effect</span></span><br><span class="line">        <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 清空postFlushCbs队列</span></span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空队列主要流程：</p><ol><li>异步执行<code>flushJob</code>，这里使用了<code>resolvedPromise.then(flushJobs)</code>。将清空队列的操作变成了异步。</li><li>清空preFlushCb队列</li><li>清空queue队列</li><li>清空postFlushCbs队列</li></ol><p>这里的“清空”是执行队列中所有任务的意思</p><h2 id="nextTick原理？"><a href="#nextTick原理？" class="headerlink" title="nextTick原理？"></a>nextTick原理？</h2><p>先看一段demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span class=&quot;my-name&quot;&gt;name: &#123;&#123;name&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; nextTick, onMounted, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const name = ref(&quot;zxfan&quot;)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  name.value += &#x27; yes!&#x27;</span><br><span class="line">  const dom = document.querySelector(&quot;.my-name&quot;)</span><br><span class="line">  </span><br><span class="line">  console.log(dom?.innerHTML); // 输出：name: zxfan</span><br><span class="line">  nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(dom?.innerHTML); // 输出：name: zxfan yes!</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由于修改响应式数据，不会立即触发组件重渲染，所以第一个<code>console.log</code>输出的内容是上一次渲染的内容。而<code>nexTick</code>注册的回调会等到在渲染完毕后执行。</p><p>我们看一下<code>nextTick</code>是如何实现的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  fn?: () =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(<span class="variable language_">this</span> ? fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，它是等promise执行完毕后在去执行回调函数。那么这个promise是什么呢？</p><ul><li><code>currentFlushPromise</code>：这个promise我们刚刚遇到过，是在<code>queueFlush</code>中赋值的。这个promise会在本轮任务队列全部清空后才会变成<code>fullfilled</code>。这是再去调用nextTick的回调，就能获取到最新的dom</li><li><code>resolvedPromise</code>：说明现在任务队列为空，那就包装一层promise并返回</li></ul><p>要理解nextTick，还需要结合浏览器的<strong>事件循环</strong>来分析，我们先明确几个知识点：</p><ol><li>浏览器的事件循环将事件放到两个队列——<strong>宏任务队列</strong>和**微任务队列</li><li>每一次事件循环，会优先先清空微任务队列</li><li>promise属于微任务</li></ol><p>以下面的demo为例，解释一下从修改响应式数据到<code>nextTick</code>中回调执行的过程</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name.<span class="property">value</span> += <span class="string">&#x27; yes!&#x27;</span></span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dom?.<span class="property">innerHTML</span>); <span class="comment">// 输出：name: zxfan yes!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>当执行<code>name.value += &#39; yes!&#39;</code>时，响应式数据发生了改变。<ul><li>触发Proxy的setter，将<strong>更新组件任务的effect</strong>放入vue任务队列中（调用queueJob）</li><li>调用queueFlush，这里调用了<code>promise.resolve</code>，所以将<strong>flushJobs</strong>放入微任务队列</li><li>此时微任务队列&#x3D; [flushJobs]</li></ul></li><li>接着执行<code>nextTick</code>。等待<code>currentFlushPromise</code>执行完毕</li><li>开始清空微任务队列。先执行flushJobs，执行<strong>更新组件任务的effect</strong>，这个过程会操作DOM，一旦操作DOM。浏览器会进行线程切换。由<strong>JS线程</strong>切换到<strong>渲染线程</strong>，浏览器去更新DOM。当DOM更新完毕，在切换回<strong>JS线程</strong>。回到JS线程后，<code>currentFlushPromise</code>状态变成<code>fullfilled</code>。将nextTick的回调<code>cb</code>放入微任务队列。此时微任务队列&#x3D; [cb]</li><li>继续清空微任务队列，执行cb。此时如果在cb中访问dom，就是渲染完成后的dom内容。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../../images/Vue/vue%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="vue任务调度.png"></p><h2 id="Vue2中的表现"><a href="#Vue2中的表现" class="headerlink" title="Vue2中的表现"></a>Vue2中的表现</h2><h3 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h3><p>vu2的任务调度原理也是类似。</p><ol><li>组件的响应式数据发生改变，会触发setter方法。</li><li>触发<code>dep.notify()</code>。</li><li>遍历dep对象上的<code>watcher</code>，逐一调用其<code>update</code>方法，（Watcher对象是在渲染组件时创建的，用来更新组件）</li><li>update再调用<code>queueWatcher</code>，将更新任务加入任务队列</li><li>调用<code>nextTick(flushSchedulerQueue)</code>，用来清空任务队列。<code>nextTick</code>是为了让组件更新变成异步。</li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>vue2中的nextTick比vue3多了些内容。</p><p>nextTick也模拟了一个回调任务队列<code>callbacks</code>（注意这不是调度的任务队列）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将回调加入队列中</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果队列没有正在执行（flush），就去清空队列</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>() <span class="comment">// 清空队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextTick调用了<code>timeFunc</code>来清空队列</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  <span class="comment">// 省略... 就是清空callbakcs任务队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 支持promise，就用promise来模拟异步</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 2. 不支持promise 就用MutationObserver来模拟异步</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.用setImmediate来模拟异步</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line"></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更多的兼容浏览器，timerFunc模拟异步判断了三种情况</p><ol><li>支持Promise，就直接用Promise来模拟异步。Promise属于微任务</li><li>不支持Promise，支持MutationObserver。MutationObserver也属于微任务<ul><li>创建一个空的文本节点，监听这个文本节点的字符变化。变化了就调用<code>flushCallbacks</code>来清空回调任务队列</li><li>调用<code>timerFunc</code>，会修改文本节点的内容，从而触发<code>flushCallbacks</code>函数的执行</li></ul></li><li><code>MutationObserver</code>和<code>Promise</code>都不支持，就用<code>setImmediate</code>来模拟异步，后者属于宏任务</li><li>最后方案就是使用setTimeout来模拟异步</li></ol><p>可见<code>vue2</code>为了兼容性，下足了功夫。而<code>vue3</code>直接就使用了<code>Promise</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在vue3中，修改一个响应式对象，像是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>栈问题梳理</title>
    <link href="https://zxffan.github.io/posts/1f4ac2fb.html"/>
    <id>https://zxffan.github.io/posts/1f4ac2fb.html</id>
    <published>2021-04-02T16:00:00.000Z</published>
    <updated>2023-06-30T11:14:18.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h2><p>栈的特性：<code>先进后出</code></p><p>数组模拟：</p><ul><li>进栈：<code>arr.push()</code></li><li>出栈：<code>arr.pop()</code></li></ul><h3 id="匹配消除"><a href="#匹配消除" class="headerlink" title="匹配消除"></a>匹配消除</h3><p>栈可以用来解决<strong>匹配</strong>问题</p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><p>括号匹配，<code>(&#123;[</code>与<code>]&#125;)</code>匹配</p><p>创建一个栈<code>stack</code>，并遍历字符串。当遇到<code>(&#123;[</code>时入栈，当遇到<code>]&#125;)</code>时，取栈顶元素比较</p><ul><li>相匹配，栈顶元素出栈，继续循环</li><li>不匹配，直接返回<code>false</code></li></ul><p>时间复杂度O(n)，空间复杂度O(n)</p><blockquote><p>如果栈中的元素都一样，就不需要用栈，用一个计数器count即可</p></blockquote><h3 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h3><p><em>题目】在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:</em></p><p><em>所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；</em></p><p><em>当方向相对时，大鱼会吃掉小鱼；</em></p><p><em>鱼的大小都不一样。</em></p><p><em>输入：Size &#x3D; [4, 2, 5, 3, 1], Dir &#x3D; [1, 1, 0, 0, 0]</em></p><p><em>输出：3</em></p><p>这道题跟上一条题原理一样都是<strong>匹配消除</strong>，上一道题是根据元素的内容（括号）来判断匹配消除。而本道题是根据元素的<strong>大小</strong>的<strong>“方向”</strong>两个条件来判断</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">LEFT</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RIGHT</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eatFish</span>(<span class="params">size: <span class="built_in">number</span>[], dir: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 还没有鱼</span></span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="property">length</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> insert = <span class="literal">true</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈顶的鱼比 当前的鱼小, 就一直循环得吃</span></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack[stack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> canMeet = dir[last] === <span class="variable constant_">RIGHT</span> &amp;&amp; dir[i] == <span class="variable constant_">LEFT</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canMeet &amp;&amp; size[last] &lt; size[i]) stack.<span class="title function_">pop</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 大鱼把栈中的所有鱼都吃完了，需要在最后将这条大鱼放入栈中</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (canMeet) &#123;</span><br><span class="line">        insert = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈中的鱼都吃完了</span></span><br><span class="line">    <span class="keyword">if</span> (insert) stack.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈分为两种：</p><ul><li>递增栈</li><li>递减栈</li></ul><h3 id="相邻最小索引"><a href="#相邻最小索引" class="headerlink" title="相邻最小索引"></a>相邻最小索引</h3><p>【题目】一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。</p><p>输入：[5, 2]</p><p>输出：[1, -1]</p><p>解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析：</span></span><br><span class="line"><span class="comment"> *  遍历数组元素，构造递增栈</span></span><br><span class="line"><span class="comment"> *  当前元素比栈顶小，则栈顶元素需要出栈，并记录栈顶元素右侧第一个小的下标为当前元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findRightSmall</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; arr[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] &gt; cur) &#123;</span><br><span class="line">      result[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] = i;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变一下问题</span></span><br><span class="line"><span class="comment">// 求左边第一个比我下的下标为止，没有则用-1表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析</span></span><br><span class="line"><span class="comment"> *  还是遍历数组元素，构造递增栈</span></span><br><span class="line"><span class="comment"> *  当前元素小于等于栈顶元素是需要出栈</span></span><br><span class="line"><span class="comment"> *  当不需要栈顶元素出栈，说明当前元素比栈顶元素大。即栈顶元素是当前元素左侧第一个小的元素，记录一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 记录之前还要排除掉相等的情况，即从栈顶往下找，一直找到一个不相同的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findLeftSmall</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; arr[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] &gt; cur) stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> top = stack.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[stack[top]] === cur) top--;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) result[i] = stack[top];</span><br><span class="line"></span><br><span class="line">    stack.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字典序最小的-k-个数的子序列"><a href="#字典序最小的-k-个数的子序列" class="headerlink" title="字典序最小的 k 个数的子序列"></a>字典序最小的 k 个数的子序列</h3><p>【题目】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。</p><p>输入：nums &#x3D; [3,5,2,6], k &#x3D; 2<br>输出：[2,6]</p><p>解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</p><p>所谓字典序就是，给定两个数组：x &#x3D; [x1,x2,x3,x4]，y &#x3D; [y1,y2,y3,y4]，如果 0 ≤ p &lt; i，xp &#x3D;&#x3D; yp 且 xi &lt; yi，那么我们认为 x 的字典序小于 y。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findSmallSeq</span>(<span class="params">seg: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; seg.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = seg[i];</span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="property">length</span> &lt;= <span class="number">0</span>) stack.<span class="title function_">push</span>(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      stack[stack.<span class="property">length</span> - <span class="number">1</span>] &gt; cur &amp;&amp;</span><br><span class="line">      stack.<span class="property">length</span> + seg.<span class="property">length</span> - i &gt; k</span><br><span class="line">    )</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span> &lt; k) stack.<span class="title function_">push</span>(cur)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单调栈的运用"><a href="#单调栈的运用" class="headerlink" title="单调栈的运用"></a>单调栈的运用</h2><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;普通栈&quot;&gt;&lt;a href=&quot;#普通栈&quot; class=&quot;headerlink&quot; title=&quot;普通栈&quot;&gt;&lt;/a&gt;普通栈&lt;/h2&gt;&lt;p&gt;栈的特性：&lt;code&gt;先进后出&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组模拟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进栈：&lt;code&gt;arr.push</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
